---
title: Erweiterte Leistungs Themen
description: Erweiterte Leistungs Themen für Entity Framework Core
author: rick-anderson
ms.author: riande
ms.date: 12/9/2020
uid: core/performance/advanced-performance-topics
ms.openlocfilehash: 3c0340e1b36cbbb96d23db0633cb2eebc04dd970
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657735"
---
# <a name="advanced-performance-topics"></a><span data-ttu-id="8197d-103">Erweiterte Leistungs Themen</span><span class="sxs-lookup"><span data-stu-id="8197d-103">Advanced Performance Topics</span></span>

## <a name="dbcontext-pooling"></a><span data-ttu-id="8197d-104">DbContext-Pooling</span><span class="sxs-lookup"><span data-stu-id="8197d-104">DbContext pooling</span></span>

<span data-ttu-id="8197d-105">`AddDbContextPool` ermöglicht das Pooling von `DbContext` Instanzen.</span><span class="sxs-lookup"><span data-stu-id="8197d-105">`AddDbContextPool` enables pooling of `DbContext` instances.</span></span> <span data-ttu-id="8197d-106">Durch das Kontext Pooling kann der Durchsatz in Szenarios mit hoher Skalierung (z. b. Webserver durch Wiederverwendung von Kontext Instanzen) gesteigert werden, anstatt für jede Anforderung neue Instanzen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="8197d-106">Context pooling can increase throughput in high-scale scenarios such as web servers by reusing context instances, rather than creating new instances for each request.</span></span>

<span data-ttu-id="8197d-107">Das typische Muster in einer ASP.net Core-APP, die EF Core verwendet, umfasst das Registrieren eines benutzerdefinierten <xref:Microsoft.EntityFrameworkCore.DbContext> Typs im Container für die [Abhängigkeitsinjektion](/aspnet/core/fundamentals/dependency-injection) und das Abrufen von Instanzen dieses Typs über Konstruktorparameter in Controllern oder Razor pages.</span><span class="sxs-lookup"><span data-stu-id="8197d-107">The typical pattern in an ASP.NET Core app using EF Core involves registering a custom <xref:Microsoft.EntityFrameworkCore.DbContext> type into the [dependency injection](/aspnet/core/fundamentals/dependency-injection) container and obtaining instances of that type through constructor parameters in controllers or Razor Pages.</span></span> <span data-ttu-id="8197d-108">Mithilfe der Konstruktorinjektion wird für jede Anforderung eine neue Kontext Instanz erstellt.</span><span class="sxs-lookup"><span data-stu-id="8197d-108">Using constructor injection, a new context instance is created for each request.</span></span>

<span data-ttu-id="8197d-109"><xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> aktiviert einen Pool von wiederverwendbaren Kontext Instanzen.</span><span class="sxs-lookup"><span data-stu-id="8197d-109"><xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> enables a pool of reusable context instances.</span></span> <span data-ttu-id="8197d-110">Um Kontext Pooling zu verwenden, verwenden Sie die- `AddDbContextPool` Methode anstelle von `AddDbContext` bei der Dienst Registrierung:</span><span class="sxs-lookup"><span data-stu-id="8197d-110">To use context pooling, use the `AddDbContextPool` method instead of `AddDbContext` during service registration:</span></span>

```csharp
services.AddDbContextPool<BloggingContext>(
    options => options.UseSqlServer(connectionString));
```

<span data-ttu-id="8197d-111">Wenn zum `AddDbContextPool` Zeitpunkt der Anforderung einer Kontext Instanz verwendet wird, prüft EF zunächst, ob eine Instanz im Pool verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="8197d-111">When `AddDbContextPool` is used, at the time a context instance is requested, EF first checks if there is an instance available in the pool.</span></span> <span data-ttu-id="8197d-112">Sobald die Anforderungsverarbeitung abgeschlossen ist, werden alle Zustände der Instanz zurückgesetzt, und die Instanz selbst wird an den Pool zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8197d-112">Once the request processing finalizes, any state on the instance is reset and the instance is itself returned to the pool.</span></span>

<span data-ttu-id="8197d-113">Dies ist konzeptionell vergleichbar mit der Funktionsweise von Verbindungspooling in ADO.NET-Anbietern und hat den Vorteil, dass einige der Kosten für die Initialisierung der Kontext Instanz eingespart werden.</span><span class="sxs-lookup"><span data-stu-id="8197d-113">This is conceptually similar to how connection pooling operates in ADO.NET providers and has the advantage of saving some of the cost of initialization of the context instance.</span></span>

<span data-ttu-id="8197d-114">Der- `poolSize` Parameter von <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> legt die maximale Anzahl von-Instanzen fest, die vom Pool beibehalten werden.</span><span class="sxs-lookup"><span data-stu-id="8197d-114">The `poolSize` parameter of <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> sets the maximum number of instances retained by the pool.</span></span> <span data-ttu-id="8197d-115">Sobald `poolSize` überschritten wird, werden neue Kontext Instanzen nicht zwischengespeichert, und EF greift auf das nicht-Pooling-Verhalten zurück, wenn Bedarfs gesteuert Instanzen erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="8197d-115">Once `poolSize` is exceeded, new context instances are not cached and  EF falls back to the non-pooling behavior of creating instances on demand.</span></span>

### <a name="limitations"></a><span data-ttu-id="8197d-116">Einschränkungen</span><span class="sxs-lookup"><span data-stu-id="8197d-116">Limitations</span></span>

<span data-ttu-id="8197d-117">Für apps sollte ein Profil erstellt und getestet werden, um anzuzeigen, dass die kontextinitialisierung einen erheblichen Aufwand verursacht.</span><span class="sxs-lookup"><span data-stu-id="8197d-117">Apps should be profiled and tested to show that context initialization is a significant cost.</span></span>

<span data-ttu-id="8197d-118">`AddDbContextPool` in gibt es einige Einschränkungen, die in der- `OnConfiguring` Methode des-Kontexts ausgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="8197d-118">`AddDbContextPool` has a few limitations on what can be done in the `OnConfiguring` method of the context.</span></span>

> [!WARNING]
> <span data-ttu-id="8197d-119">Vermeiden Sie die Verwendung von Kontext Pooling in apps, die den Zustand beibehalten.</span><span class="sxs-lookup"><span data-stu-id="8197d-119">Avoid using context pooling in apps that maintain state.</span></span> <span data-ttu-id="8197d-120">Beispielsweise private Felder im Kontext, die nicht über Anforderungen hinweg freigegeben werden sollten.</span><span class="sxs-lookup"><span data-stu-id="8197d-120">For example, private fields in the context that shouldn't be shared across requests.</span></span> <span data-ttu-id="8197d-121">EF Core setzt den Zustand, den es kennt, nur dann zurück, wenn dem Pool eine Kontext Instanz hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="8197d-121">EF Core only resets the state that it is aware of before adding a context instance to the pool.</span></span>

<span data-ttu-id="8197d-122">Das Kontext Pooling verwendet die gleiche Kontext Instanz in allen Anforderungen.</span><span class="sxs-lookup"><span data-stu-id="8197d-122">Context pooling works by reusing the same context instance across requests.</span></span> <span data-ttu-id="8197d-123">Dies bedeutet, dass Sie als [Singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) in Bezug auf die Instanz selbst registriert ist, damit Sie persistent gespeichert werden kann.</span><span class="sxs-lookup"><span data-stu-id="8197d-123">This means that it's effectively registered as a [Singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) in terms of the instance itself so that it's able to persist.</span></span>

<span data-ttu-id="8197d-124">Das Kontext Pooling ist für Szenarien vorgesehen, in denen die Kontext Konfiguration, die die aufgelösten Dienste umfasst, zwischen Anforderungen korrigiert wird.</span><span class="sxs-lookup"><span data-stu-id="8197d-124">Context pooling is intended for scenarios where the context configuration, which includes services resolved, is fixed between requests.</span></span> <span data-ttu-id="8197d-125">Für Fälle, [in denen](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) Bereichs bezogene Dienste erforderlich sind oder die Konfiguration geändert werden muss, verwenden Sie Pooling nicht.</span><span class="sxs-lookup"><span data-stu-id="8197d-125">For cases where [Scoped](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) services are required, or configuration needs to be changed, don't use pooling.</span></span> <span data-ttu-id="8197d-126">Der Leistungsgewinn von Pooling ist in der Regel mit Ausnahme von hochgradig optimierten Szenarien unerheblich.</span><span class="sxs-lookup"><span data-stu-id="8197d-126">The performance gain from pooling is usually negligible except in highly optimized scenarios.</span></span>

## <a name="query-caching-and-parameterization"></a><span data-ttu-id="8197d-127">Zwischenspeichern von Abfragen und Parametrisierung</span><span class="sxs-lookup"><span data-stu-id="8197d-127">Query caching and parameterization</span></span>

<span data-ttu-id="8197d-128">Wenn EF eine LINQ-Abfrage Struktur zur Ausführung empfängt, muss die Struktur zuerst in eine SQL-Abfrage kompiliert werden.</span><span class="sxs-lookup"><span data-stu-id="8197d-128">When EF receives a LINQ query tree for execution, it must first "compile" that tree into a SQL query.</span></span> <span data-ttu-id="8197d-129">Da es sich hierbei um einen hohen Prozess handelt, speichert EF Abfragen nach der *Form* des Abfrage Baums zwischen: Abfragen mit derselben Struktur verwenden intern zwischengespeicherte Kompilierungs Ausgaben und können die wiederholte Kompilierung überspringen.</span><span class="sxs-lookup"><span data-stu-id="8197d-129">Because this is a heavy process, EF caches queries by the query tree *shape*: queries with the same structure reuse internally-cached compilation outputs, and can skip repeated compilation.</span></span> <span data-ttu-id="8197d-130">Die unterschiedlichen Abfragen verweisen möglicherweise weiterhin auf andere *Werte*, aber solange diese Werte ordnungsgemäß parametrisiert sind, ist die Struktur identisch, und die Zwischenspeicherung funktioniert ordnungsgemäß.</span><span class="sxs-lookup"><span data-stu-id="8197d-130">The different queries may still reference different *values*, but as long as these values are properly parameterized, the structure is the same and caching will function properly.</span></span>

<span data-ttu-id="8197d-131">Beachten Sie die folgenden beiden Abfragen:</span><span class="sxs-lookup"><span data-stu-id="8197d-131">Consider the following two queries:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithConstants)]

<span data-ttu-id="8197d-132">Da die Ausdrucks Baumstrukturen unterschiedliche Konstanten enthalten, unterscheidet sich die Ausdrucks Baumstruktur, und jede dieser Abfragen wird separat durch EF Core kompiliert.</span><span class="sxs-lookup"><span data-stu-id="8197d-132">Since the expression trees contains different constants, the expression tree differs and each of these queries will be compiled separately by EF Core.</span></span> <span data-ttu-id="8197d-133">Außerdem erzeugt jede Abfrage einen etwas anderen SQL-Befehl:</span><span class="sxs-lookup"><span data-stu-id="8197d-133">In addition, each query produces a slightly different SQL command:</span></span>

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog1'

SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog2'
```

<span data-ttu-id="8197d-134">Da SQL sich unterscheidet, muss der Datenbankserver wahrscheinlich auch einen Abfrageplan für beide Abfragen und nicht denselben Plan wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="8197d-134">Because the SQL differs, your database server will likely also need to produce a query plan for both queries, rather than reusing the same plan.</span></span>

<span data-ttu-id="8197d-135">Eine kleine Änderung an Ihren Abfragen kann die Dinge erheblich ändern:</span><span class="sxs-lookup"><span data-stu-id="8197d-135">A small modification to your queries can change things considerably:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithParameterization)]

<span data-ttu-id="8197d-136">Da der Blog Name nun *parametrisiert* ist, haben beide Abfragen dieselbe Struktur Form, und EF muss nur einmal kompiliert werden.</span><span class="sxs-lookup"><span data-stu-id="8197d-136">Since the blog name is now *parameterized*, both queries have the same tree shape, and EF only needs to be compiled once.</span></span> <span data-ttu-id="8197d-137">Der erstellte SQL-Code wird ebenfalls parametrisiert, sodass die Datenbank denselben Abfrageplan wieder verwenden kann:</span><span class="sxs-lookup"><span data-stu-id="8197d-137">The SQL produced is also parameterized, allowing the database to reuse the same query plan:</span></span>

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = @__blogName_0
```

<span data-ttu-id="8197d-138">Beachten Sie, dass es nicht erforderlich ist, jede einzelne Abfrage zu parametrisieren: Es ist in Ordnung, einige Abfragen mit Konstanten zu haben, und Datenbanken (und EF) können manchmal bestimmte Optimierungen für Konstanten ausführen, die bei parametrisierten Abfragen nicht möglich sind.</span><span class="sxs-lookup"><span data-stu-id="8197d-138">Note that there is no need to parameterize each and every query: it's perfectly fine to have some queries with constants, and indeed, databases (and EF) can sometimes perform certain optimization around constants which aren't possible when the query is parameterized.</span></span> <span data-ttu-id="8197d-139">Ein Beispiel für eine wichtige Parametrisierung finden Sie im Abschnitt über [dynamisch erstellte Abfragen](#dynamically-constructed-queries) .</span><span class="sxs-lookup"><span data-stu-id="8197d-139">See the section on [dynamically-constructed queries](#dynamically-constructed-queries) for an example where proper parameterization is crucial.</span></span>

> [!NOTE]
> <span data-ttu-id="8197d-140">Die [Ereignis](xref:core/logging-events-diagnostics/event-counters) Indikatoren von EF Core melden die Trefferquote für den Abfrage Cache.</span><span class="sxs-lookup"><span data-stu-id="8197d-140">EF Core's [event counters](xref:core/logging-events-diagnostics/event-counters) report the Query Cache Hit Rate.</span></span> <span data-ttu-id="8197d-141">In einer normalen Anwendung erreicht dieser Wert nach dem Programmstart 100%, sobald die meisten Abfragen mindestens einmal ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="8197d-141">In a normal application, this counter reaches 100% soon after program startup, once most queries have executed at least once.</span></span> <span data-ttu-id="8197d-142">Wenn dieser Indikator unter 100% stabil bleibt, weist dies darauf hin, dass Ihre Anwendung möglicherweise etwas bewirkt, das den Abfragecache unterscheidet. es ist ratsam, dies zu untersuchen.</span><span class="sxs-lookup"><span data-stu-id="8197d-142">If this counter remains stable below 100%, that is an indication that your application may be doing something which defeats the query cache - it's a good idea to investigate that.</span></span>

> [!NOTE]
> <span data-ttu-id="8197d-143">Die Art und Weise, wie die Datenbank Cache-Abfrage Pläne verwaltet, ist Daten Bank abhängig</span><span class="sxs-lookup"><span data-stu-id="8197d-143">How the database manages caches query plans is database-dependent.</span></span> <span data-ttu-id="8197d-144">Beispielsweise wird von SQL Server implizit ein LRU-Abfrageplan Cache verwaltet, während dies bei PostgreSQL nicht der gibt (aber vorbereitete-Anweisungen können zu einem sehr ähnlichen Endeffekt führen).</span><span class="sxs-lookup"><span data-stu-id="8197d-144">For example, SQL Server implicitly maintains an LRU query plan cache, whereas PostgreSQL does not (but prepared statements can produce a very similar end effect).</span></span> <span data-ttu-id="8197d-145">Weitere Informationen finden Sie in der Datenbankdokumentation.</span><span class="sxs-lookup"><span data-stu-id="8197d-145">Consult your database documentation for more details.</span></span>

## <a name="dynamically-constructed-queries"></a><span data-ttu-id="8197d-146">Dynamisch erstellte Abfragen</span><span class="sxs-lookup"><span data-stu-id="8197d-146">Dynamically-constructed queries</span></span>

<span data-ttu-id="8197d-147">In einigen Situationen ist es notwendig, LINQ-Abfragen dynamisch zu erstellen, anstatt Sie im Quellcode direkt anzugeben.</span><span class="sxs-lookup"><span data-stu-id="8197d-147">In some situations, it is necessary to dynamically construct LINQ queries rather than specifying them outright in source code.</span></span> <span data-ttu-id="8197d-148">Dies kann z. b. auf einer Website vorkommen, die beliebige Abfrage Details von einem Client empfängt, mit offenen Abfrage Operatoren (Sortieren, Filtern, Paging...). Im Prinzip können dynamisch erstellte Abfragen bei ordnungsgemäßer Ausführung genauso effizient sein wie reguläre (obwohl es nicht möglich ist, die kompilierte Abfrageoptimierung mit dynamischen Abfragen zu verwenden).</span><span class="sxs-lookup"><span data-stu-id="8197d-148">This can happen, for example, in a website which receives arbitrary query details from a client, with open-ended query operators (sorting, filtering, paging...). In principle, if done correctly, dynamically-constructed queries can be just as efficient as regular ones (although it's not possible to use the compiled query optimization with dynamic queries).</span></span> <span data-ttu-id="8197d-149">In der Praxis handelt es sich jedoch häufig um Leistungsprobleme, da es einfach ist, Ausdrucks Baumstrukturen mit Formen zu schaffen, die sich jedes Mal voneinander unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="8197d-149">In practice, however, they are frequently the source of performance issues, since it's easy to accidentally produce expression trees with shapes that differ every time.</span></span>

<span data-ttu-id="8197d-150">Im folgenden Beispiel werden zwei Techniken verwendet, um eine Abfrage dynamisch zu erstellen: `Where` der Abfrage wird nur dann ein Operator hinzugefügt, wenn der angegebene Parameter nicht NULL ist.</span><span class="sxs-lookup"><span data-stu-id="8197d-150">The following example uses two techniques to dynamically construct a query; we add a `Where` operator to the query only if the given parameter is not null.</span></span> <span data-ttu-id="8197d-151">Beachten Sie, dass dies kein guter Anwendungsfall für das dynamische Erstellen einer Abfrage ist, aber wir verwenden Sie zur Vereinfachung:</span><span class="sxs-lookup"><span data-stu-id="8197d-151">Note that this isn't a good use case for dynamically constructing a query - but we're using it for simplicity:</span></span>

### <a name="with-constant"></a>[<span data-ttu-id="8197d-152">Mit Konstante</span><span class="sxs-lookup"><span data-stu-id="8197d-152">With constant</span></span>](#tab/with-constant)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithConstant&highlight=14-24)]

### <a name="with-parameter"></a>[<span data-ttu-id="8197d-153">With-Parameter</span><span class="sxs-lookup"><span data-stu-id="8197d-153">With parameter</span></span>](#tab/with-parameter)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithParameter&highlight=14)]

***

<span data-ttu-id="8197d-154">Das Benchmarkverfahren führt zu den folgenden Ergebnissen:</span><span class="sxs-lookup"><span data-stu-id="8197d-154">Benchmarking these two techniques gives the following results:</span></span>

|        <span data-ttu-id="8197d-155">Methode</span><span class="sxs-lookup"><span data-stu-id="8197d-155">Method</span></span> |       <span data-ttu-id="8197d-156">Mittelwert</span><span class="sxs-lookup"><span data-stu-id="8197d-156">Mean</span></span> |    <span data-ttu-id="8197d-157">Fehler</span><span class="sxs-lookup"><span data-stu-id="8197d-157">Error</span></span> |    <span data-ttu-id="8197d-158">StdDev</span><span class="sxs-lookup"><span data-stu-id="8197d-158">StdDev</span></span> |   <span data-ttu-id="8197d-159">Gen 0</span><span class="sxs-lookup"><span data-stu-id="8197d-159">Gen 0</span></span> |  <span data-ttu-id="8197d-160">Gen 1</span><span class="sxs-lookup"><span data-stu-id="8197d-160">Gen 1</span></span> | <span data-ttu-id="8197d-161">Gen 2</span><span class="sxs-lookup"><span data-stu-id="8197d-161">Gen 2</span></span> | <span data-ttu-id="8197d-162">Zugeordnet</span><span class="sxs-lookup"><span data-stu-id="8197d-162">Allocated</span></span> |
|-------------- |-----------:|---------:|----------:|--------:|-------:|------:|----------:|
|  <span data-ttu-id="8197d-163">Withconstant</span><span class="sxs-lookup"><span data-stu-id="8197d-163">WithConstant</span></span> | <span data-ttu-id="8197d-164">1.096,7 US-</span><span class="sxs-lookup"><span data-stu-id="8197d-164">1,096.7 us</span></span> | <span data-ttu-id="8197d-165">12,54 US-</span><span class="sxs-lookup"><span data-stu-id="8197d-165">12.54 us</span></span> |  <span data-ttu-id="8197d-166">11,12 US-</span><span class="sxs-lookup"><span data-stu-id="8197d-166">11.12 us</span></span> | <span data-ttu-id="8197d-167">13,6719</span><span class="sxs-lookup"><span data-stu-id="8197d-167">13.6719</span></span> | <span data-ttu-id="8197d-168">1,9531</span><span class="sxs-lookup"><span data-stu-id="8197d-168">1.9531</span></span> |     - |  <span data-ttu-id="8197d-169">83,91 KB</span><span class="sxs-lookup"><span data-stu-id="8197d-169">83.91 KB</span></span> |
| <span data-ttu-id="8197d-170">Withparameter</span><span class="sxs-lookup"><span data-stu-id="8197d-170">WithParameter</span></span> |   <span data-ttu-id="8197d-171">570,8 US-</span><span class="sxs-lookup"><span data-stu-id="8197d-171">570.8 us</span></span> | <span data-ttu-id="8197d-172">42,43 US-</span><span class="sxs-lookup"><span data-stu-id="8197d-172">42.43 us</span></span> | <span data-ttu-id="8197d-173">124,43 US-</span><span class="sxs-lookup"><span data-stu-id="8197d-173">124.43 us</span></span> |  <span data-ttu-id="8197d-174">5,8594</span><span class="sxs-lookup"><span data-stu-id="8197d-174">5.8594</span></span> |      - |     - |  <span data-ttu-id="8197d-175">37,16 KB</span><span class="sxs-lookup"><span data-stu-id="8197d-175">37.16 KB</span></span> |

<span data-ttu-id="8197d-176">Auch wenn der Unterschied zwischen unter Millisekunden gering erscheint, sollten Sie Bedenken, dass die Konstante Version den Cache kontinuierlich verschmutzt und die erneute Kompilierung anderer Abfragen bewirkt.</span><span class="sxs-lookup"><span data-stu-id="8197d-176">Even if the sub-millisecond difference seems small, keep in mind that the constant version continuously pollutes the cache and causes other queries to be re-compiled, slowing them down as well.</span></span>

> [!NOTE]
> <span data-ttu-id="8197d-177">Vermeiden Sie das Erstellen von Abfragen mit der Ausdrucks Baumstruktur-API, es sei denn, Sie müssen</span><span class="sxs-lookup"><span data-stu-id="8197d-177">Avoid constructing queries with the expression tree API unless you really need to.</span></span> <span data-ttu-id="8197d-178">Abgesehen von der Komplexität der API ist es sehr einfach, bei der Verwendung versehentlich erhebliche Leistungsprobleme zu verursachen.</span><span class="sxs-lookup"><span data-stu-id="8197d-178">Aside from the API's complexity, it's very easy to inadvertently cause significant performance issues when using them.</span></span>
