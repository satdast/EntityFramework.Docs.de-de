---
title: Effiziente Abfrage-EF Core
description: Leistungs Leit Faden für effiziente Abfragen mithilfe von Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/efficient-querying
ms.openlocfilehash: acd5388745e74a42925c8500ce610aef83e75384
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657714"
---
# <a name="efficient-querying"></a><span data-ttu-id="97c33-103">Effiziente Abfragen</span><span class="sxs-lookup"><span data-stu-id="97c33-103">Efficient Querying</span></span>

<span data-ttu-id="97c33-104">Das effiziente Abfragen ist ein umfassender Artikel, der Themen wie Indizes, zugehörige Entitäts Lade Strategien und viele andere Themen behandelt.</span><span class="sxs-lookup"><span data-stu-id="97c33-104">Querying efficiently is a vast subject, that covers subjects as wide-ranging as indexes, related entity loading strategies, and many others.</span></span> <span data-ttu-id="97c33-105">In diesem Abschnitt werden einige gängige Themen zum schnelleren Ausführen von Abfragen erläutert</span><span class="sxs-lookup"><span data-stu-id="97c33-105">This section details some common themes for making your queries faster, and pitfalls users typically encounter.</span></span>

## <a name="use-indexes-properly"></a><span data-ttu-id="97c33-106">Ordnungsgemäße Verwendung von Indizes</span><span class="sxs-lookup"><span data-stu-id="97c33-106">Use indexes properly</span></span>

<span data-ttu-id="97c33-107">Der wichtigste Entscheidungsfaktor, ob eine Abfrage schnell ausgeführt wird oder nicht, ist, ob Sie ggf. Indizes ordnungsgemäß verwendet: Datenbanken werden normalerweise verwendet, um große Datenmengen zu speichern, und Abfragen, die ganze Tabellen durchlaufen, sind in der Regel Quellen für schwerwiegende Leistungsprobleme.</span><span class="sxs-lookup"><span data-stu-id="97c33-107">The main deciding factor in whether a query runs fast or not is whether it will properly utilize indexes where appropriate: databases are typically used to hold large amounts of data, and queries which traverse entire tables are typically sources of serious performance issues.</span></span> <span data-ttu-id="97c33-108">Indizierungs Probleme sind nicht leicht zu erkennen, weil es nicht sofort ersichtlich ist, ob eine bestimmte Abfrage einen Index verwendet oder nicht.</span><span class="sxs-lookup"><span data-stu-id="97c33-108">Indexing issues aren't easy to spot, because it isn't immediately obvious whether a given query will use an index or not.</span></span> <span data-ttu-id="97c33-109">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="97c33-109">For example:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Indexes)]

<span data-ttu-id="97c33-110">Eine gute Möglichkeit, Indizierungs Probleme zu erkennen, besteht darin, zuerst eine langsame Abfrage zu ermitteln und dann den Abfrageplan über das bevorzugte Tool Ihrer Datenbank zu untersuchen. Weitere Informationen zur Vorgehensweise finden Sie auf der Seite " [Leistungs Diagnose](xref:core/performance/performance-diagnosis) ".</span><span class="sxs-lookup"><span data-stu-id="97c33-110">A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via your database's favorite tool; see the [performance diagnosis](xref:core/performance/performance-diagnosis) page for more information on how to do that.</span></span> <span data-ttu-id="97c33-111">Der Abfrageplan zeigt an, ob die Abfrage die gesamte Tabelle durchläuft oder einen Index verwendet.</span><span class="sxs-lookup"><span data-stu-id="97c33-111">The query plan displays whether the query traverses the entire table, or uses an index.</span></span>

<span data-ttu-id="97c33-112">Als allgemeine Regel gilt: Es gibt keine speziellen EF-Kenntnisse zur Verwendung von Indizes oder zur Diagnose von Leistungsproblemen, die im Zusammenhang mit Ihnen auftreten. Allgemeine Daten Bank Kenntnisse im Zusammenhang mit Indizes sind für EF-Anwendungen ebenso wichtig wie für Anwendungen, die EF nicht verwenden.</span><span class="sxs-lookup"><span data-stu-id="97c33-112">As a general rule, there isn't any special EF knowledge to using indexes or diagnosing performance issues related to them; general database knowledge related to indexes is just as relevant to EF applications as to applications not using EF.</span></span> <span data-ttu-id="97c33-113">Im folgenden sind einige allgemeine Richtlinien aufgeführt, die bei der Verwendung von Indizes beachtet werden sollten:</span><span class="sxs-lookup"><span data-stu-id="97c33-113">The following lists some general guidelines to keep in mind when using indexes:</span></span>

* <span data-ttu-id="97c33-114">Obwohl Indizes Abfragen beschleunigen, verlangsamen Sie auch Updates, da Sie auf dem neuesten Stand gehalten werden müssen.</span><span class="sxs-lookup"><span data-stu-id="97c33-114">While indexes speed up queries, they also slow down updates since they need to be kept up-to-date.</span></span> <span data-ttu-id="97c33-115">Vermeiden Sie die Definition von Indizes, die nicht benötigt werden, und verwenden Sie ggf. [Index Filter](xref:core/modeling/indexes#index-filter) , um den Index auf eine Teilmenge der Zeilen einzuschränken, wodurch der Aufwand verringert wird.</span><span class="sxs-lookup"><span data-stu-id="97c33-115">Avoid defining indexes which aren't needed, and consider using [index filters](xref:core/modeling/indexes#index-filter) to limit the index to a subset of the rows, thereby reducing this overhead.</span></span>
* <span data-ttu-id="97c33-116">Zusammengesetzte Indizes können Abfragen beschleunigen, die mehrere Spalten filtern, aber Sie können auch Abfragen beschleunigen, die nicht nach allen Spalten des Indexes Filtern (abhängig von der Reihenfolge).</span><span class="sxs-lookup"><span data-stu-id="97c33-116">Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don't filter on all the index's columns - depending on ordering.</span></span> <span data-ttu-id="97c33-117">Ein Index für die Spalten a und b beschleunigt z. b. Abfragen, die durch a und b gefiltert werden, sowie Abfragen, die nur durch einen filtern. es werden jedoch keine Abfragen beschleunigt, die nur durch B gefiltert werden.</span><span class="sxs-lookup"><span data-stu-id="97c33-117">For example, an index on columns A and B speed up queries filtering by A and B, as well as queries filtering only by A, but it does not speed up queries filtering over only by B.</span></span>
* <span data-ttu-id="97c33-118">Wenn eine Abfrage anhand eines Ausdrucks über eine Spalte (z. b.) filtert `price / 2` , kann kein einfacher Index verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="97c33-118">If a query filters by an expression over a column (e.g. `price / 2`), a simple index cannot be used.</span></span> <span data-ttu-id="97c33-119">Sie können jedoch eine gespeicherte beibehaltene [Spalte](xref:core/modeling/generated-properties#computed-columns) für ihren Ausdruck definieren und einen Index dafür erstellen.</span><span class="sxs-lookup"><span data-stu-id="97c33-119">However, you can define a [stored persisted column](xref:core/modeling/generated-properties#computed-columns) for your expression, and create an index over that.</span></span> <span data-ttu-id="97c33-120">Einige Datenbanken unterstützen auch Ausdrucks Indizes, die direkt verwendet werden können, um Abfragen zu beschleunigen, die durch einen beliebigen Ausdruck gefiltert werden.</span><span class="sxs-lookup"><span data-stu-id="97c33-120">Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression.</span></span>
* <span data-ttu-id="97c33-121">Mit unterschiedlichen Datenbanken können Indizes auf verschiedene Weise konfiguriert werden, und in vielen Fällen EF Core Anbieter diese über die fließende API verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="97c33-121">Different databases allow indexes to be configured in various ways, and in many cases EF Core providers expose these via the Fluent API.</span></span> <span data-ttu-id="97c33-122">Beispielsweise können Sie mit dem SQL Server-Anbieter konfigurieren, ob ein Index [gruppiert](xref:core/providers/sql-server/indexes#clustering)ist, oder den [Füllfaktor](xref:core/providers/sql-server/indexes#fill-factor)festlegen.</span><span class="sxs-lookup"><span data-stu-id="97c33-122">For example, the SQL Server provider allows you to configure whether an index is [clustered](xref:core/providers/sql-server/indexes#clustering), or set its [fill factor](xref:core/providers/sql-server/indexes#fill-factor).</span></span> <span data-ttu-id="97c33-123">Weitere Informationen finden Sie in der Dokumentation des Anbieters.</span><span class="sxs-lookup"><span data-stu-id="97c33-123">Consult your provider's documentation for more information.</span></span>

## <a name="project-only-properties-you-need"></a><span data-ttu-id="97c33-124">Nur Projekteigenschaften, die Sie benötigen</span><span class="sxs-lookup"><span data-stu-id="97c33-124">Project only properties you need</span></span>

<span data-ttu-id="97c33-125">Mit EF Core ist es sehr einfach, Entitäts Instanzen abzufragen und diese Instanzen dann im Code zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="97c33-125">EF Core makes it very easy to query out entity instances, and then use those instances in code.</span></span> <span data-ttu-id="97c33-126">Beim Abfragen von Entitäts Instanzen können jedoch häufig mehr Daten als notwendig aus der Datenbank abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="97c33-126">However, querying entity instances can frequently pull back more data than necessary from your database.</span></span> <span data-ttu-id="97c33-127">Beachten Sie Folgendes:</span><span class="sxs-lookup"><span data-stu-id="97c33-127">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectEntities)]

<span data-ttu-id="97c33-128">Obwohl dieser Code nur die-Eigenschaft jedes Blogs benötigt `Url` , wird die gesamte Blog-Entität abgerufen und nicht benötigte Spalten aus der Datenbank übertragen:</span><span class="sxs-lookup"><span data-stu-id="97c33-128">Although this code only actually needs each Blog's `Url` property, the entire Blog entity is fetched, and unneeded columns are transferred from the database:</span></span>

```sql
SELECT [b].[BlogId], [b].[CreationDate], [b].[Name], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="97c33-129">Dies kann mithilfe von optimiert werden `Select` , um EF mitzuteilen, welche Spalten zu projizieren sind:</span><span class="sxs-lookup"><span data-stu-id="97c33-129">This can be optimized by using `Select` to tell EF which columns to project out:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectSingleProperty)]

<span data-ttu-id="97c33-130">Das resultierende SQL ruft nur die benötigten Spalten zurück:</span><span class="sxs-lookup"><span data-stu-id="97c33-130">The resulting SQL pulls back only the needed columns:</span></span>

```csharp
SELECT [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="97c33-131">Wenn Sie mehr als eine Spalte projizieren müssen, projizieren Sie die gewünschten Eigenschaften in einen anonymen c#-Typ.</span><span class="sxs-lookup"><span data-stu-id="97c33-131">If you need to project out more than one column, project out to a C# anonymous type with the properties you want.</span></span>

<span data-ttu-id="97c33-132">Beachten Sie, dass diese Technik für schreibgeschützte Abfragen sehr nützlich ist. es wird jedoch komplizierter, wenn Sie die abgerufenen Blogs *Aktualisieren* müssen, da die Änderungs Nachverfolgung von EF nur mit Entitäts Instanzen funktioniert.</span><span class="sxs-lookup"><span data-stu-id="97c33-132">Note that this technique is very useful for read-only queries, but things get more complicated if you need to *update* the fetched blogs, since EF's change tracking only works with entity instances.</span></span> <span data-ttu-id="97c33-133">Es ist möglich, Aktualisierungen auszuführen, ohne ganze Entitäten zu laden, indem Sie eine geänderte Blog Instanz anfügen und EF mitteilen, welche Eigenschaften geändert wurden, aber das ist eine erweiterte Technik, die sich möglicherweise nicht lohnt.</span><span class="sxs-lookup"><span data-stu-id="97c33-133">It's possible to perform updates without loading entire entities by attaching a modified Blog instance and telling EF which properties have changed, but that is a more advanced technique that may not be worth it.</span></span>

## <a name="limit-the-resultset-size"></a><span data-ttu-id="97c33-134">Begrenzen der Größe des Resultsets</span><span class="sxs-lookup"><span data-stu-id="97c33-134">Limit the resultset size</span></span>

<span data-ttu-id="97c33-135">Standardmäßig gibt eine Abfrage alle Zeilen zurück, die mit Ihren Filtern übereinstimmen:</span><span class="sxs-lookup"><span data-stu-id="97c33-135">By default, a query returns all rows that matches its filters:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NoLimit)]

<span data-ttu-id="97c33-136">Da die Anzahl der zurückgegebenen Zeilen von den tatsächlichen Daten in der Datenbank abhängt, ist es nicht möglich zu wissen, wie viele Daten aus der Datenbank geladen werden, wie viel Arbeitsspeicher von den Ergebnissen belegt wird und wie viel zusätzliche Auslastung bei der Verarbeitung dieser Ergebnisse generiert wird (z. b. durch Senden an einen Benutzer Browser über das Netzwerk).</span><span class="sxs-lookup"><span data-stu-id="97c33-136">Since the number of rows returned depends on actual data in your database, it's impossible to know how much data will be loaded from the database, how much memory will be taken up by the results, and how much additional load will be generated when processing these results (e.g. by sending them to a user browser over the network).</span></span> <span data-ttu-id="97c33-137">Entscheidend ist, dass Testdatenbanken häufig wenig Daten enthalten, sodass alles gut funktioniert, wenn die Abfrage in realen Daten ausgeführt wird und viele Zeilen zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="97c33-137">Crucially, test databases frequently contain little data, so that everything works well while testing, but performance problems suddenly appear when the query starts running on real-world data and many rows are returned.</span></span>

<span data-ttu-id="97c33-138">Daher ist es in der Regel sinnvoll, die Anzahl der Ergebnisse einzuschränken:</span><span class="sxs-lookup"><span data-stu-id="97c33-138">As a result, it's usually worth giving thought to limiting the number of results:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Limit25)]

<span data-ttu-id="97c33-139">Die Benutzeroberfläche kann mindestens eine Meldung anzeigen, die besagt, dass in der Datenbank mehr Zeilen vorhanden sein können (und Sie auf andere Weise abrufen können).</span><span class="sxs-lookup"><span data-stu-id="97c33-139">At a minimum, your UI could show a message indicating that more rows may exist in the database (and allow retrieving them in some other manner).</span></span> <span data-ttu-id="97c33-140">Eine vollständige Lösung würde das *Paging* implementieren, bei dem Ihre Benutzeroberfläche nur eine bestimmte Anzahl von Zeilen gleichzeitig anzeigt und Benutzern ermöglicht, bei Bedarf zur nächsten Seite zu gelangen. in der Regel werden <xref:System.Linq.Enumerable.Take%2A> die <xref:System.Linq.Enumerable.Skip%2A> Operatoren und kombiniert, um jedes Mal einen bestimmten Bereich im Resultset auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="97c33-140">A full-blown solution would implement *paging*, where your UI only shows a certain number of rows at a time, and allow users to advance to the next page as needed; this typically combines the <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> operators to select a specific range in the resultset each time.</span></span>

## <a name="avoid-cartesian-explosion-when-loading-related-entities"></a><span data-ttu-id="97c33-141">Vermeiden der kartesischen Explosion beim Laden verwandter Entitäten</span><span class="sxs-lookup"><span data-stu-id="97c33-141">Avoid cartesian explosion when loading related entities</span></span>

<span data-ttu-id="97c33-142">In relationalen Datenbanken werden alle zugehörigen Entitäten standardmäßig durch Einführung von JOIN-Vorgängen in eine Einzelabfrage geladen.</span><span class="sxs-lookup"><span data-stu-id="97c33-142">In relational databases, all related entities are loaded by introducing JOINs in single query.</span></span>

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
```

<span data-ttu-id="97c33-143">Wenn ein typischer Blog mehrere zugehörige Beiträge enthält, werden in den Zeilen für diese Beiträge die Informationen des Blogs dupliziert.</span><span class="sxs-lookup"><span data-stu-id="97c33-143">If a typical blog has multiple related posts, rows for these posts will duplicate the blog's information.</span></span> <span data-ttu-id="97c33-144">Diese Duplizierung führt zum so genannten Problem der „kartesischen Explosion“.</span><span class="sxs-lookup"><span data-stu-id="97c33-144">This duplication leads to the so-called "cartesian explosion" problem.</span></span> <span data-ttu-id="97c33-145">Wenn weitere 1:n-Beziehungen geladen werden, wächst die Menge an duplizierten Daten weiter und beeinträchtigt die Leistung Ihrer Anwendung.</span><span class="sxs-lookup"><span data-stu-id="97c33-145">As more one-to-many relationships are loaded, the amount of duplicated data may grow and adversely affect the performance of your application.</span></span>

<span data-ttu-id="97c33-146">EF ermöglicht die Vermeidung dieses Effekts durch die Verwendung von "Split Queries", die die verknüpften Entitäten über separate Abfragen laden.</span><span class="sxs-lookup"><span data-stu-id="97c33-146">EF allows avoiding this effect via the use of "split queries", which load the related entities via separate queries.</span></span> <span data-ttu-id="97c33-147">Weitere Informationen finden Sie [in der Dokumentation zu Split und Single Queries](xref:core/querying/single-split-queries).</span><span class="sxs-lookup"><span data-stu-id="97c33-147">For more information, read [the documentation on split and single queries](xref:core/querying/single-split-queries).</span></span>

> [!NOTE]
> <span data-ttu-id="97c33-148">Die aktuelle Implementierung von [Split-Abfragen](xref:core/querying/single-split-queries) führt einen Roundtrip für jede Abfrage aus.</span><span class="sxs-lookup"><span data-stu-id="97c33-148">The current implementation of [split queries](xref:core/querying/single-split-queries) executes a roundtrip for each query.</span></span> <span data-ttu-id="97c33-149">Wir planen, dies in Zukunft zu verbessern und alle Abfragen in einem einzigen Roundtrip auszuführen.</span><span class="sxs-lookup"><span data-stu-id="97c33-149">We plan to improve this in the future, and execute all queries in a single roundtrip.</span></span>

## <a name="load-related-entities-eagerly-when-possible"></a><span data-ttu-id="97c33-150">Verwandte Entitäten nach Möglichkeit eifrig laden</span><span class="sxs-lookup"><span data-stu-id="97c33-150">Load related entities eagerly when possible</span></span>

<span data-ttu-id="97c33-151">Es wird empfohlen, [die dedizierte Seite für Verwandte Entitäten](xref:core/querying/related-data) zu lesen, bevor Sie mit diesem Abschnitt fortfahren.</span><span class="sxs-lookup"><span data-stu-id="97c33-151">It's recommended to read [the dedicated page on related entities](xref:core/querying/related-data) before continuing with this section.</span></span>

<span data-ttu-id="97c33-152">Beim Umgang mit verwandten Entitäten wissen wir in der Regel, was wir laden müssen: ein typisches Beispiel wäre das Laden einer bestimmten Gruppe von Blogs zusammen mit allen Beiträgen.</span><span class="sxs-lookup"><span data-stu-id="97c33-152">When dealing with related entities, we usually know in advance what we need to load: a typical example would be loading a certain set of Blogs, along with all their Posts.</span></span> <span data-ttu-id="97c33-153">In diesen Szenarien ist es immer besser, [Eager Loading](xref:core/querying/related-data/eager)zu verwenden, damit EF alle erforderlichen Daten in einem Roundtrip abrufen kann.</span><span class="sxs-lookup"><span data-stu-id="97c33-153">In these scenarios, it is always better to use [eager loading](xref:core/querying/related-data/eager), so that EF can fetch all the required data in one roundtrip.</span></span> <span data-ttu-id="97c33-154">Das [gefilterte include](xref:core/querying/related-data/eager#filtered-include) -Feature, das in EF Core 5,0 eingeführt wurde, ermöglicht Ihnen außerdem, zu begrenzen, welche verknüpften Entitäten Sie laden möchten, während der Ladeprozess in einem einzigen Roundtrip erwartungsgemäß bleibt:</span><span class="sxs-lookup"><span data-stu-id="97c33-154">The [filtered include](xref:core/querying/related-data/eager#filtered-include) feature, introduced in EF Core 5.0, also allows you to limit which related entities you'd like to load, while keeping the loading process eager and therefore doable in a single roundtrip:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs#FilteredInclude)]

<span data-ttu-id="97c33-155">In anderen Szenarien wissen wir möglicherweise nicht, welche verwandte Entität wir benötigen, bevor wir die Prinzipal Entität erhalten.</span><span class="sxs-lookup"><span data-stu-id="97c33-155">In other scenarios, we may not know which related entity we're going to need before we get its principal entity.</span></span> <span data-ttu-id="97c33-156">Wenn Sie z. b. einen Blog laden, müssen wir uns möglicherweise eine andere Datenquelle (möglicherweise einen Webdienst) ansehen, um zu erfahren, ob wir an den Beiträgen dieses Blogs interessiert sind.</span><span class="sxs-lookup"><span data-stu-id="97c33-156">For example, when loading some Blog, we may need to consult some other data source - possibly a webservice - in order to know whether we're interested in that Blog's Posts.</span></span> <span data-ttu-id="97c33-157">In diesen Fällen kann [explizites](xref:core/querying/related-data/explicit) oder [Lazy](xref:core/querying/related-data/lazy) Load verwendet werden, um verknüpfte Entitäten separat abzurufen und die Post-Navigation des Blogs aufzufüllen.</span><span class="sxs-lookup"><span data-stu-id="97c33-157">In these cases, [explicit](xref:core/querying/related-data/explicit) or [lazy](xref:core/querying/related-data/lazy) loading can be used to fetch related entities separately, and populate the Blog's Posts navigation.</span></span> <span data-ttu-id="97c33-158">Beachten Sie, dass, da diese Methoden nicht eifrig sind, zusätzliche Roundtrips zur Datenbank erforderlich sind, d. h. die Quelle der Verlangsamung. abhängig von Ihrem speziellen Szenario ist es möglicherweise effizienter, alle Beiträge immer zu laden, anstatt die zusätzlichen Roundtrips auszuführen und selektiv nur die benötigten Beiträge zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="97c33-158">Note that since these methods aren't eager, they require additional roundtrips to the database, which is source of slowdown; depending on your specific scenario, it may be more efficient to just always load all Posts, rather than to execute the additional roundtrips and selectively get only the Posts you need.</span></span>

### <a name="beware-of-lazy-loading"></a><span data-ttu-id="97c33-159">Vorsicht Lazy Loading</span><span class="sxs-lookup"><span data-stu-id="97c33-159">Beware of lazy loading</span></span>

<span data-ttu-id="97c33-160">[Lazy Load](xref:core/querying/related-data/lazy) scheint eine sehr nützliche Methode zum Schreiben von Daten Bank Logik zu sein, da EF Core automatisch verknüpfte Entitäten aus der Datenbank lädt, wenn der Code auf Sie zugreift.</span><span class="sxs-lookup"><span data-stu-id="97c33-160">[Lazy loading](xref:core/querying/related-data/lazy) often seems like a very useful way to write database logic, since EF Core automatically loads related entities from the database as they are accessed by your code.</span></span> <span data-ttu-id="97c33-161">Dadurch wird vermieden, dass verknüpfte Entitäten geladen werden, die nicht benötigt werden (z. b. [Explizites Laden](xref:core/querying/related-data/explicit))</span><span class="sxs-lookup"><span data-stu-id="97c33-161">This avoids loading related entities that aren't needed (like [explicit loading](xref:core/querying/related-data/explicit)), and seemingly frees the programmer from having to deal with related entities altogether.</span></span> <span data-ttu-id="97c33-162">Lazy Loading ist jedoch besonders anfällig für die Erstellung nicht benötigter zusätzlicher Roundtrips, die die Anwendung verlangsamen können.</span><span class="sxs-lookup"><span data-stu-id="97c33-162">However, lazy loading is particularly prone for producing unneeded extra roundtrips which can slow the application.</span></span>

<span data-ttu-id="97c33-163">Beachten Sie Folgendes:</span><span class="sxs-lookup"><span data-stu-id="97c33-163">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NPlusOne)]

<span data-ttu-id="97c33-164">Dieser scheinbar unschuldige Code Abschnitt durchläuft alle Blogs und ihre Beiträge und druckt sie. Beim Aktivieren der [Anweisungs Protokollierung](xref:core/logging-events-diagnostics/index) von EF Core wird Folgendes angezeigt:</span><span class="sxs-lookup"><span data-stu-id="97c33-164">This seemingly innocent piece of code iterates through all the blogs and their posts, printing them out. Turning on EF Core's [statement logging](xref:core/logging-events-diagnostics/index) reveals the following:</span></span>

```console
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[BlogId], [b].[Rating], [b].[Url]
      FROM [Blogs] AS [b]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__p_0='1'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='2'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='3'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0

... and so on
```

<span data-ttu-id="97c33-165">Was geht da vor?</span><span class="sxs-lookup"><span data-stu-id="97c33-165">What's going on here?</span></span> <span data-ttu-id="97c33-166">Warum werden all diese Abfragen für die oben genannten einfachen Schleifen gesendet?</span><span class="sxs-lookup"><span data-stu-id="97c33-166">Why are all these queries being sent for the simple loops above?</span></span> <span data-ttu-id="97c33-167">Bei Lazy Loading werden die Beiträge eines Blogs nur (verzögert) geladen, wenn auf seine Posts-Eigenschaft zugegriffen wird. Folglich löst jede Iterationen im Inneren foreach eine zusätzliche Datenbankabfrage in einem eigenen Roundtrip aus.</span><span class="sxs-lookup"><span data-stu-id="97c33-167">With lazy loading, a Blog's Posts are only (lazily) loaded when its Posts property is accessed; as a result, each iteration in the inner foreach triggers an additional database query, in its own roundtrip.</span></span> <span data-ttu-id="97c33-168">Nachdem die erste Abfrage alle Blogs geladen hat, haben wir daher eine weitere Abfrage *pro Blog*, die alle Beiträge lädt. Dies wird manchmal als " *N + 1* "-Problem bezeichnet und kann zu erheblichen Leistungsproblemen führen.</span><span class="sxs-lookup"><span data-stu-id="97c33-168">As a result, after the initial query loading all the blogs, we then have another query *per blog*, loading all its posts; this is sometimes called the *N+1* problem, and it can cause very significant performance issues.</span></span>

<span data-ttu-id="97c33-169">Angenommen, wir benötigen alle Blogbeiträge, aber es ist sinnvoll, stattdessen Eager Loading zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="97c33-169">Assuming we're going to need all of the blogs' posts, it makes sense to use eager loading here instead.</span></span> <span data-ttu-id="97c33-170">Wir können den [include](xref:core/querying/related-data/eager#eager-loading) -Operator verwenden, um das Laden auszuführen, aber da wir nur die URLs der Blogs benötigen (und nur die [benötigten Elemente laden](xref:core/performance/efficient-updating#project-only-properties-you-need)sollten).</span><span class="sxs-lookup"><span data-stu-id="97c33-170">We can use the [Include](xref:core/querying/related-data/eager#eager-loading) operator to perform the loading, but since we only need the Blogs' URLs (and we should only [load what's needed](xref:core/performance/efficient-updating#project-only-properties-you-need)).</span></span> <span data-ttu-id="97c33-171">Wir verwenden stattdessen eine Projektion:</span><span class="sxs-lookup"><span data-stu-id="97c33-171">So we'll use a projection instead:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#EagerlyLoadRelatedAndProject)]

<span data-ttu-id="97c33-172">Dadurch wird EF Core alle Blogs zusammen mit ihren Beiträgen in einer einzigen Abfrage abrufen können.</span><span class="sxs-lookup"><span data-stu-id="97c33-172">This will make EF Core fetch all the Blogs - along with their Posts - in a single query.</span></span> <span data-ttu-id="97c33-173">In einigen Fällen kann es auch hilfreich sein, kartesische Explosions Effekte mithilfe von Split- [Abfragen](xref:core/querying/single-split-queries)zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="97c33-173">In some cases, it may also be useful to avoid cartesian explosion effects by using [split queries](xref:core/querying/single-split-queries).</span></span>

> [!WARNING]
> <span data-ttu-id="97c33-174">Da Lazy Loading das Auftreten des Problems mit N + 1 äußerst einfach machen kann, empfiehlt es sich, dies zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="97c33-174">Because lazy loading makes it extremely easy to inadvertently trigger the N+1 problem, it is recommended to avoid it.</span></span> <span data-ttu-id="97c33-175">Ein eifriges oder explizites Laden macht es im Quellcode ganz klar, wenn ein datenbankroundtrip auftritt.</span><span class="sxs-lookup"><span data-stu-id="97c33-175">Eager or explicit loading make it very clear in the source code when a database roundtrip occurs.</span></span>

## <a name="buffering-and-streaming"></a><span data-ttu-id="97c33-176">Pufferung und Streaming</span><span class="sxs-lookup"><span data-stu-id="97c33-176">Buffering and streaming</span></span>

<span data-ttu-id="97c33-177">Die Pufferung bezieht sich auf das Laden aller Abfrageergebnisse in den Arbeitsspeicher, während Streaming bedeutet, dass EF die Anwendung jedes Mal ein einzelnes Ergebnis übergibt, ohne dass das gesamte Resultset im Arbeitsspeicher enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="97c33-177">Buffering refers to loading all your query results into memory, whereas streaming means that that EF hands the application a single result each time, never containing the entire resultset in memory.</span></span> <span data-ttu-id="97c33-178">Im Prinzip werden die Arbeitsspeicher Anforderungen einer streaminganfrage korrigiert. Sie sind identisch, unabhängig davon, ob die Abfrage eine Zeile oder 1000 zurückgibt. eine Puffer Abfrage hingegen erfordert mehr Arbeitsspeicher, je mehr Zeilen zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="97c33-178">In principle, the memory requirements of a streaming query are fixed - they are the same whether the query returns 1 row or 1000; a buffering query, on the other hand, requires more memory the more rows are returned.</span></span> <span data-ttu-id="97c33-179">Bei Abfragen, die umfangreiche Resultsets ergeben, kann dies ein wichtiger Leistungsfaktor sein.</span><span class="sxs-lookup"><span data-stu-id="97c33-179">For queries that result large resultsets, this can be an important performance factor.</span></span>

<span data-ttu-id="97c33-180">Ob ein Abfrage Puffer oder Datenströme von der Auswertung abhängig sind:</span><span class="sxs-lookup"><span data-stu-id="97c33-180">Whether a query buffers or streams depends on how it is evaluated:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#BufferingAndStreaming)]

<span data-ttu-id="97c33-181">Wenn Ihre Abfragen nur ein paar Ergebnisse zurückgeben, müssen Sie sich nicht darum kümmern.</span><span class="sxs-lookup"><span data-stu-id="97c33-181">If your queries return just a few results, then you probably don't have to worry about this.</span></span> <span data-ttu-id="97c33-182">Wenn die Abfrage jedoch möglicherweise eine große Anzahl von Zeilen zurückgibt, ist es sinnvoll, das Streaming anstelle von Pufferung zu überdenken.</span><span class="sxs-lookup"><span data-stu-id="97c33-182">However, if your query might return large numbers of rows, it's worth giving thought to streaming instead of buffering.</span></span>

> [!NOTE]
> <span data-ttu-id="97c33-183">Vermeiden <xref:System.Linq.Enumerable.ToList%2A> <xref:System.Linq.Enumerable.ToArray%2A> Sie die Verwendung von oder, wenn Sie einen anderen LINQ-Operator für das Ergebnis verwenden möchten. Dadurch werden alle Ergebnisse unnötig in den Arbeitsspeicher gepuffert.</span><span class="sxs-lookup"><span data-stu-id="97c33-183">Avoid using <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> if you intend to use another LINQ operator on the result - this will needlessly buffer all results into memory.</span></span> <span data-ttu-id="97c33-184">Verwenden Sie stattdessen <xref:System.Linq.Enumerable.AsEnumerable%2A>.</span><span class="sxs-lookup"><span data-stu-id="97c33-184">Use <xref:System.Linq.Enumerable.AsEnumerable%2A> instead.</span></span>

### <a name="internal-buffering-by-ef"></a><span data-ttu-id="97c33-185">Interne Pufferung von EF</span><span class="sxs-lookup"><span data-stu-id="97c33-185">Internal buffering by EF</span></span>

<span data-ttu-id="97c33-186">In bestimmten Situationen wird das Resultset unabhängig davon, wie Sie die Abfrage auswerten, von EF intern gepuffert.</span><span class="sxs-lookup"><span data-stu-id="97c33-186">In certain situations, EF will itself buffer the resultset internally, regardless of how you evaluate your query.</span></span> <span data-ttu-id="97c33-187">Dies sind die beiden Fälle, in denen dies geschieht:</span><span class="sxs-lookup"><span data-stu-id="97c33-187">The two cases where this happens are:</span></span>

* <span data-ttu-id="97c33-188">Wenn eine Wiederholungs Ausführungs Strategie vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="97c33-188">When a retrying execution strategy is in place.</span></span> <span data-ttu-id="97c33-189">Dadurch wird sichergestellt, dass die gleichen Ergebnisse zurückgegeben werden, wenn die Abfrage später wiederholt wird.</span><span class="sxs-lookup"><span data-stu-id="97c33-189">This is done to make sure the same results are returned if the query is retried later.</span></span>
* <span data-ttu-id="97c33-190">Wenn [Split Query](xref:core/querying/single-split-queries) verwendet wird, werden die Resultsets aller außer der letzten Abfrage gepuffert, es sei denn, Mars ist für SQL Server aktiviert.</span><span class="sxs-lookup"><span data-stu-id="97c33-190">When [split query](xref:core/querying/single-split-queries) is used, the resultsets of all but the last query are buffered - unless MARS is enabled on SQL Server.</span></span> <span data-ttu-id="97c33-191">Dies liegt daran, dass es in der Regel nicht möglich ist, mehrere Resultsets für Abfragen gleichzeitig zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="97c33-191">This is because it is usually impossible to have multiple query resultsets active at the same time.</span></span>

<span data-ttu-id="97c33-192">Beachten Sie, dass diese interne Pufferung zusätzlich zu sämtlicher Pufferung erfolgt, die Sie über LINQ-Operatoren auslösen.</span><span class="sxs-lookup"><span data-stu-id="97c33-192">Note that this internal buffering occurs in addition to any buffering you cause via LINQ operators.</span></span> <span data-ttu-id="97c33-193">Wenn Sie z. b. für <xref:System.Linq.Enumerable.ToList%2A> eine Abfrage verwenden und eine Wiederholungs Ausführungs Strategie vorhanden ist, wird das Resultset *zweimal* in den Arbeitsspeicher geladen: einmal intern von EF und einmal von <xref:System.Linq.Enumerable.ToList%2A> .</span><span class="sxs-lookup"><span data-stu-id="97c33-193">For example, if you use <xref:System.Linq.Enumerable.ToList%2A> on a query and a retrying execution strategy is in place, the resultset is loaded into memory *twice*: once internally by EF, and once by <xref:System.Linq.Enumerable.ToList%2A>.</span></span>

## <a name="tracking-no-tracking-and-identity-resolution"></a><span data-ttu-id="97c33-194">Nachverfolgung, keine Nachverfolgung und Identitäts Auflösung</span><span class="sxs-lookup"><span data-stu-id="97c33-194">Tracking, no-tracking and identity resolution</span></span>

<span data-ttu-id="97c33-195">Es wird empfohlen, [die dedizierte Seite zur Überwachung und ohne Nachverfolgung](xref:core/querying/tracking) zu lesen, bevor Sie mit diesem Abschnitt fortfahren.</span><span class="sxs-lookup"><span data-stu-id="97c33-195">It's recommended to read [the dedicated page on tracking and no-tracking](xref:core/querying/tracking) before continuing with this section.</span></span>

<span data-ttu-id="97c33-196">EF verfolgt standardmäßig Entitäts Instanzen, sodass Änderungen an den Instanzen erkannt und persistent gespeichert werden, wenn <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="97c33-196">EF tracks entity instances by default, so that changes on them are detected and persisted when <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called.</span></span> <span data-ttu-id="97c33-197">Ein weiterer Effekt bei der Nachverfolgung von Abfragen besteht darin, dass EF erkennt, ob bereits eine Instanz für Ihre Daten geladen wurde, und dass diese überwachte Instanz automatisch zurückgegeben wird, anstatt eine neue Instanz zurückzugeben. Dies wird als *Identitäts Auflösung* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="97c33-197">Another effect of tracking queries is that EF detects if an instance has already been loaded for your data, and will automatically return that tracked instance rather than returning a new one; this is called *identity resolution*.</span></span> <span data-ttu-id="97c33-198">Im Hinblick auf die Leistung bedeutet die Änderungs Nachverfolgung Folgendes:</span><span class="sxs-lookup"><span data-stu-id="97c33-198">From a performance perspective, change tracking means the following:</span></span>

* <span data-ttu-id="97c33-199">EF verwaltet intern ein Wörterbuch mit nach verfolgten Instanzen.</span><span class="sxs-lookup"><span data-stu-id="97c33-199">EF internally maintains a dictionary of tracked instances.</span></span> <span data-ttu-id="97c33-200">Wenn neue Daten geladen werden, prüft EF das Wörterbuch, um festzustellen, ob bereits eine Instanz für den Schlüssel der Entität (Identitäts Auflösung) nachverfolgt wird.</span><span class="sxs-lookup"><span data-stu-id="97c33-200">When new data is loaded, EF checks the dictionary to see if an instance is already tracked for that entity's key (identity resolution).</span></span> <span data-ttu-id="97c33-201">Die Wörterbuch Wartung und Suchvorgänge nehmen einige Zeit in Anspruch, wenn die Ergebnisse der Abfrage geladen werden.</span><span class="sxs-lookup"><span data-stu-id="97c33-201">The dictionary maintenance and lookups take up some time when loading the query's results.</span></span>
* <span data-ttu-id="97c33-202">Bevor eine geladene Instanz an die Anwendung übergeben *wird, erstellt EF diese* Instanz und speichert die Momentaufnahme intern.</span><span class="sxs-lookup"><span data-stu-id="97c33-202">Before handing a loaded instance to the application, EF *snapshots* that instance and keeps the snapshot internally.</span></span> <span data-ttu-id="97c33-203">Wenn <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> aufgerufen wird, wird die Instanz der Anwendung mit der Momentaufnahme verglichen, um die Änderungen zu ermitteln, die persistent gespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="97c33-203">When <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called, the application's instance is compared with the snapshot to discover the changes to be persisted.</span></span> <span data-ttu-id="97c33-204">Die Momentaufnahme benötigt mehr Arbeitsspeicher, und der Snapshotprozess selbst nimmt Zeit in Rechnung. Manchmal ist es möglich, ein anderes, möglicherweise effizienteres snapshotverhalten über [Wert Vergleiche](xref:core/modeling/value-comparers)anzugeben oder Proxys für die Änderungs Nachverfolgung zu verwenden, um den Snapshotprozess vollständig zu umgehen (Dies ist jedoch mit einem eigenen Satz von Nachteilen verbunden).</span><span class="sxs-lookup"><span data-stu-id="97c33-204">The snapshot takes up more memory, and the snapshotting process itself takes time; it's sometimes possible to specify different, possibly more efficient snapshotting behavior via [value comparers](xref:core/modeling/value-comparers), or to use change-tracking proxies to bypass the snapshotting process altogether (though that comes with its own set of disadvantages).</span></span>

<span data-ttu-id="97c33-205">In schreibgeschützten Szenarien, in denen Änderungen nicht in der Datenbank gespeichert werden, können die oben genannten Aufwand mithilfe von [Abfragen ohne Nachverfolgung](xref:core/querying/tracking#no-tracking-queries)vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="97c33-205">In read-only scenarios where changes aren't saved back to the database, the above overheads can be avoided by using [no-tracking queries](xref:core/querying/tracking#no-tracking-queries).</span></span> <span data-ttu-id="97c33-206">Da keine nach Verfolgungs Abfragen jedoch keine Identitäts Auflösung durchführen, wird eine Datenbankzeile, auf die von mehreren anderen geladenen Zeilen verwiesen wird, als unterschiedliche Instanzen materialisiert.</span><span class="sxs-lookup"><span data-stu-id="97c33-206">However, since no-tracking queries do not perform identity resolution, a database row which is referenced by multiple other loaded rows will be materialized as as different instances.</span></span>

<span data-ttu-id="97c33-207">Um dies zu veranschaulichen, nehmen wir an, dass wir eine große Anzahl von Beiträgen aus der Datenbank laden, ebenso wie der Blog, auf den jeder Beitrag verweist.</span><span class="sxs-lookup"><span data-stu-id="97c33-207">To illustrate, assume we are loading a large number of Posts from the database, as well as the Blog referenced by each Post.</span></span> <span data-ttu-id="97c33-208">Wenn 100 Beiträge auf denselben Blog verweisen, erkennt eine Überwachungs Abfrage dies über die Identitäts Auflösung, und alle Post-Instanzen verweisen auf dieselbe deduplizierte Blog Instanz.</span><span class="sxs-lookup"><span data-stu-id="97c33-208">If 100 Posts happen to reference the same Blog, a tracking query detects this via identity resolution, and all Post instances will refer the same de-duplicated Blog instance.</span></span> <span data-ttu-id="97c33-209">Eine Abfrage ohne Nachverfolgung hingegen dupliziert denselben Blog 100-Mal, und der Anwendungscode muss entsprechend geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="97c33-209">A no-tracking query, in contrast, duplicates the same Blog 100 times - and application code must be written accordingly.</span></span>

<span data-ttu-id="97c33-210">Im folgenden finden Sie die Ergebnisse für einen Vergleichstest zum Vergleichen von Nachverfolgung und ohne Nachverfolgung für eine Abfrage, bei der 10 Blogs mit 20 Beiträgen geladen werden.</span><span class="sxs-lookup"><span data-stu-id="97c33-210">Here are the results for a benchmark comparing tracking vs. no-tracking behavior for a query loading 10 Blogs with 20 Posts each.</span></span> <span data-ttu-id="97c33-211">[Der Quellcode ist hier verfügbar](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs). Sie können ihn als Grundlage für Ihre eigenen Messungen verwenden.</span><span class="sxs-lookup"><span data-stu-id="97c33-211">[The source code is available here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs), feel free to use it as a basis for your own measurements.</span></span>

|       <span data-ttu-id="97c33-212">Methode</span><span class="sxs-lookup"><span data-stu-id="97c33-212">Method</span></span> | <span data-ttu-id="97c33-213">Numblogs</span><span class="sxs-lookup"><span data-stu-id="97c33-213">NumBlogs</span></span> | <span data-ttu-id="97c33-214">Numpostsperblog</span><span class="sxs-lookup"><span data-stu-id="97c33-214">NumPostsPerBlog</span></span> |       <span data-ttu-id="97c33-215">Mittelwert</span><span class="sxs-lookup"><span data-stu-id="97c33-215">Mean</span></span> |    <span data-ttu-id="97c33-216">Fehler</span><span class="sxs-lookup"><span data-stu-id="97c33-216">Error</span></span> |   <span data-ttu-id="97c33-217">StdDev</span><span class="sxs-lookup"><span data-stu-id="97c33-217">StdDev</span></span> |     <span data-ttu-id="97c33-218">Median</span><span class="sxs-lookup"><span data-stu-id="97c33-218">Median</span></span> | <span data-ttu-id="97c33-219">Seitenverhältnis</span><span class="sxs-lookup"><span data-stu-id="97c33-219">Ratio</span></span> | <span data-ttu-id="97c33-220">Ratiosd</span><span class="sxs-lookup"><span data-stu-id="97c33-220">RatioSD</span></span> |   <span data-ttu-id="97c33-221">Gen 0</span><span class="sxs-lookup"><span data-stu-id="97c33-221">Gen 0</span></span> |   <span data-ttu-id="97c33-222">Gen 1</span><span class="sxs-lookup"><span data-stu-id="97c33-222">Gen 1</span></span> | <span data-ttu-id="97c33-223">Gen 2</span><span class="sxs-lookup"><span data-stu-id="97c33-223">Gen 2</span></span> | <span data-ttu-id="97c33-224">Zugeordnet</span><span class="sxs-lookup"><span data-stu-id="97c33-224">Allocated</span></span> |
|------------- |--------- |---------------- |-----------:|---------:|---------:|-----------:|------:|--------:|--------:|--------:|------:|----------:|
|   <span data-ttu-id="97c33-225">Astracking</span><span class="sxs-lookup"><span data-stu-id="97c33-225">AsTracking</span></span> |       <span data-ttu-id="97c33-226">10</span><span class="sxs-lookup"><span data-stu-id="97c33-226">10</span></span> |              <span data-ttu-id="97c33-227">20</span><span class="sxs-lookup"><span data-stu-id="97c33-227">20</span></span> | <span data-ttu-id="97c33-228">1.414,7 US-</span><span class="sxs-lookup"><span data-stu-id="97c33-228">1,414.7 us</span></span> | <span data-ttu-id="97c33-229">27,20 US-</span><span class="sxs-lookup"><span data-stu-id="97c33-229">27.20 us</span></span> | <span data-ttu-id="97c33-230">45,44 US-</span><span class="sxs-lookup"><span data-stu-id="97c33-230">45.44 us</span></span> | <span data-ttu-id="97c33-231">1.405,5 US-</span><span class="sxs-lookup"><span data-stu-id="97c33-231">1,405.5 us</span></span> |  <span data-ttu-id="97c33-232">1.00</span><span class="sxs-lookup"><span data-stu-id="97c33-232">1.00</span></span> |    <span data-ttu-id="97c33-233">0.00</span><span class="sxs-lookup"><span data-stu-id="97c33-233">0.00</span></span> | <span data-ttu-id="97c33-234">60,5469</span><span class="sxs-lookup"><span data-stu-id="97c33-234">60.5469</span></span> | <span data-ttu-id="97c33-235">13,6719</span><span class="sxs-lookup"><span data-stu-id="97c33-235">13.6719</span></span> |     - | <span data-ttu-id="97c33-236">380,11 KB</span><span class="sxs-lookup"><span data-stu-id="97c33-236">380.11 KB</span></span> |
| <span data-ttu-id="97c33-237">AsNoTracking</span><span class="sxs-lookup"><span data-stu-id="97c33-237">AsNoTracking</span></span> |       <span data-ttu-id="97c33-238">10</span><span class="sxs-lookup"><span data-stu-id="97c33-238">10</span></span> |              <span data-ttu-id="97c33-239">20</span><span class="sxs-lookup"><span data-stu-id="97c33-239">20</span></span> |   <span data-ttu-id="97c33-240">993,3 US-</span><span class="sxs-lookup"><span data-stu-id="97c33-240">993.3 us</span></span> | <span data-ttu-id="97c33-241">24,04 US-</span><span class="sxs-lookup"><span data-stu-id="97c33-241">24.04 us</span></span> | <span data-ttu-id="97c33-242">65,40 US-</span><span class="sxs-lookup"><span data-stu-id="97c33-242">65.40 us</span></span> |   <span data-ttu-id="97c33-243">966,2 US-</span><span class="sxs-lookup"><span data-stu-id="97c33-243">966.2 us</span></span> |  <span data-ttu-id="97c33-244">0.71</span><span class="sxs-lookup"><span data-stu-id="97c33-244">0.71</span></span> |    <span data-ttu-id="97c33-245">0.05</span><span class="sxs-lookup"><span data-stu-id="97c33-245">0.05</span></span> | <span data-ttu-id="97c33-246">37,1094</span><span class="sxs-lookup"><span data-stu-id="97c33-246">37.1094</span></span> |  <span data-ttu-id="97c33-247">6,8359</span><span class="sxs-lookup"><span data-stu-id="97c33-247">6.8359</span></span> |     - | <span data-ttu-id="97c33-248">232,89 KB</span><span class="sxs-lookup"><span data-stu-id="97c33-248">232.89 KB</span></span> |

<span data-ttu-id="97c33-249">Schließlich ist es möglich, Updates ohne den Aufwand der Änderungs Nachverfolgung durchzuführen, indem eine Abfrage ohne Nachverfolgung genutzt und dann die zurückgegebene Instanz an den Kontext angefügt wird. dabei wird angegeben, welche Änderungen vorgenommen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="97c33-249">Finally, it is possible to perform updates without the overhead of change tracking, by utilizing a no-tracking query and then attaching the returned instance to the context, specifying which changes are to be made.</span></span> <span data-ttu-id="97c33-250">Dies überträgt die Last der Änderungs Nachverfolgung von EF auf den Benutzer und sollte nur dann versucht werden, wenn der mehr Aufwand für die Änderungs Nachverfolgung durch Profilerstellung oder Benchmarktests als nicht akzeptabel angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="97c33-250">This transfers the burden of change tracking from EF to the user, and should only be attempted if the change tracking overhead has been shown to be unacceptable via profiling or benchmarking.</span></span>

## <a name="using-raw-sql"></a><span data-ttu-id="97c33-251">Verwenden von RAW SQL</span><span class="sxs-lookup"><span data-stu-id="97c33-251">Using raw SQL</span></span>

<span data-ttu-id="97c33-252">In einigen Fällen ist eine optimierte SQL-Datei für die Abfrage vorhanden, die EF nicht generiert.</span><span class="sxs-lookup"><span data-stu-id="97c33-252">In some cases, more optimized SQL exists for your query, which EF does not generate.</span></span> <span data-ttu-id="97c33-253">Dies kann der Fall sein, wenn das SQL-Konstrukt eine Erweiterung für Ihre Datenbank ist, die nicht unterstützt wird, oder nur, weil EF noch nicht in die Datenbank übersetzt wird.</span><span class="sxs-lookup"><span data-stu-id="97c33-253">This can happen when the SQL construct is an extension specific to your database that's unsupported, or simply because EF does not translate to it yet.</span></span> <span data-ttu-id="97c33-254">In diesen Fällen kann das Schreiben von SQL durch Hand eine beträchtliche Leistungssteigerung bieten, und EF unterstützt mehrere Möglichkeiten.</span><span class="sxs-lookup"><span data-stu-id="97c33-254">In these cases, writing SQL by hand can provide a substantial performance boost, and EF supports several ways to do this.</span></span>

* <span data-ttu-id="97c33-255">Verwenden Sie Rohdaten von SQL [direkt in der Abfrage](xref:core/querying/raw-sql), z. b. über <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A> .</span><span class="sxs-lookup"><span data-stu-id="97c33-255">Use raw SQL [directly in your query](xref:core/querying/raw-sql), e.g. via <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A>.</span></span> <span data-ttu-id="97c33-256">EF ermöglicht Ihnen sogar das Verfassen von SQL-Rohdaten mit regulären LINQ-Abfragen, sodass Sie nur einen Teil der Abfrage in unformatierten SQL-Daten Ausdrücken können.</span><span class="sxs-lookup"><span data-stu-id="97c33-256">EF even lets you compose over the raw SQL with regular LINQ queries, allowing you to express only a part of the query in raw SQL.</span></span> <span data-ttu-id="97c33-257">Dies ist eine gute Methode, wenn die unformatierte SQL-Datei nur in einer einzelnen Abfrage in ihrer CodeBase verwendet werden muss.</span><span class="sxs-lookup"><span data-stu-id="97c33-257">This is a good technique when the raw SQL only needs to be used in a single query in your codebase.</span></span>
* <span data-ttu-id="97c33-258">Definieren Sie eine [benutzerdefinierte Funktion (User-Defined Function](xref:core/querying/database-functions) , UDF), und nennen Sie Sie dann in Ihren Abfragen.</span><span class="sxs-lookup"><span data-stu-id="97c33-258">Define a [user-defined function](xref:core/querying/database-functions) (UDF), and then call that from your queries.</span></span> <span data-ttu-id="97c33-259">Beachten Sie, dass EF seit 5,0 das Zurückgeben von vollständigen Resultsets ermöglicht. Diese werden als Tabellenwert Funktionen (Table-Wert Functions, TVFs) bezeichnet und ermöglichen außerdem die Zuordnung einer `DbSet` zu einer Funktion, sodass Sie genau wie in einer anderen Tabelle aussieht.</span><span class="sxs-lookup"><span data-stu-id="97c33-259">Note that since 5.0, EF allows UDFs to return full resultsets - these are known as table-valued functions (TVFs) - and also allows mapping a `DbSet` to a function, making it look just like just another table.</span></span>
* <span data-ttu-id="97c33-260">Definieren Sie eine Daten Bank Sicht, und Fragen Sie Sie in Ihren Abfragen ab.</span><span class="sxs-lookup"><span data-stu-id="97c33-260">Define a database view and query from it in your queries.</span></span> <span data-ttu-id="97c33-261">Beachten Sie, dass Sichten im Gegensatz zu Funktionen keine Parameter annehmen können.</span><span class="sxs-lookup"><span data-stu-id="97c33-261">Note that unlike functions, views cannot accept parameters.</span></span>

> [!NOTE]
> <span data-ttu-id="97c33-262">Unformatierte SQL-Daten sollten in der Regel als letztes Mittel verwendet werden, nachdem sichergestellt wurde, dass EF das gewünschte SQL nicht generieren kann, und wenn die Leistung für die jeweilige Abfrage recht wichtig ist.</span><span class="sxs-lookup"><span data-stu-id="97c33-262">Raw SQL should generally be used as a last resort, after making sure that EF can't generate the SQL you want, and when performance is important enough for the given query to justify it.</span></span> <span data-ttu-id="97c33-263">Die Verwendung von RAW SQL bringt erhebliche Wartungs Nachteile mit sich.</span><span class="sxs-lookup"><span data-stu-id="97c33-263">Using raw SQL brings considerable maintenance disadvantages.</span></span>

## <a name="asynchronous-programming"></a><span data-ttu-id="97c33-264">Asynchrone Programmierung</span><span class="sxs-lookup"><span data-stu-id="97c33-264">Asynchronous programming</span></span>

<span data-ttu-id="97c33-265">Als allgemeine Regel gilt: Wenn die Anwendung skalierbar sein soll, ist es wichtig, immer asynchrone APIs anstelle von synchronen APIs zu verwenden (z. b. <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> anstelle von <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> ).</span><span class="sxs-lookup"><span data-stu-id="97c33-265">As a general rule, in order for your application to be scalable, it's important to always use asynchronous APIs rather than synchronous one (e.g. <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> rather than <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>).</span></span> <span data-ttu-id="97c33-266">Synchrone APIs blockieren den Thread für die Dauer der Datenbank-e/a, wodurch die Notwendigkeit von Threads und die Anzahl von Thread Kontext Schaltern erhöht werden muss.</span><span class="sxs-lookup"><span data-stu-id="97c33-266">Synchronous APIs block the thread for the duration of database I/O, increasing the need for threads and the number of thread context switches that must occur.</span></span>

<span data-ttu-id="97c33-267">Weitere Informationen finden Sie auf der Seite zu [Async-Programmierung](xref:core/miscellaneous/async).</span><span class="sxs-lookup"><span data-stu-id="97c33-267">For more information, see the page on [async programming](xref:core/miscellaneous/async).</span></span>

> [!WARNING]
> <span data-ttu-id="97c33-268">Vermeiden Sie das Kombinieren von synchronem und asynchronem Code in derselben Anwendung. es ist sehr einfach, Probleme mit einem geringfügigen Thread Pool zu beheben.</span><span class="sxs-lookup"><span data-stu-id="97c33-268">Avoid mixing synchronous and asynchronous code in the same application - it's very easy to inadvertently trigger subtle thread-pool starvation issues.</span></span>
