---
title: Einführung in die Leistung – EF Core
description: Leistungsleitfaden zur effizienten Verwendung von Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/miscellaneous/performance/index
ms.openlocfilehash: 14400d81ea3c93e2ebf40e8e585a457abf31478f
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657685"
---
# <a name="introduction-to-performance"></a><span data-ttu-id="01a88-103">Einführung in die Leistung</span><span class="sxs-lookup"><span data-stu-id="01a88-103">Introduction to Performance</span></span>

<span data-ttu-id="01a88-104">Die Datenbankleistung ist ein breites und komplexes Thema, das einen ganzen Stapel von Komponenten umfasst: die Datenbank, das Netzwerk, der Datenbanktreiber und die Datenzugriffsebenen, wie z. B. EF Core.</span><span class="sxs-lookup"><span data-stu-id="01a88-104">Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core.</span></span> <span data-ttu-id="01a88-105">Obwohl allgemeine Ebenen und O/RMs wie EF Core die Anwendungsentwicklung erheblich vereinfachen und die Wartbarkeit von Anwendungen verbessern, können sie unter Umständen opak sein und leistungskritische interne Details verbergen, wie z. B. die SQL-Anweisung, die gerade ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="01a88-105">While high-level layers and O/RMs such as EF Core considerably simplify application development and improve maintainability, they can sometimes be opaque, hiding performance-critical internal details such as the SQL being executed.</span></span> <span data-ttu-id="01a88-106">In diesem Artikel wird eine Übersicht darüber geboten, wie Sie mit EF Core eine gute Leistung erzielen und häufige Fehler vermeiden, die die Anwendungsleistung beeinträchtigen können.</span><span class="sxs-lookup"><span data-stu-id="01a88-106">This section attempts to provide an overview of how to achieve good performance with EF Core, and how to avoid common pitfalls which can degrade application performance.</span></span>

## <a name="identify-bottlenecks-and-measure-measure-measure"></a><span data-ttu-id="01a88-107">Erkennen von Engpässen und gründliches Messen</span><span class="sxs-lookup"><span data-stu-id="01a88-107">Identify bottlenecks and measure, measure, measure</span></span>

<span data-ttu-id="01a88-108">Wie immer bei der Leistung ist es wichtig, keine übereilte Optimierung vorzunehmen, wenn Daten zu einem Problem fehlen. Denken Sie an die Worte von Donald Knuth: „Eine vorzeitige Optimierung ist die Wurzel alles Bösen“.</span><span class="sxs-lookup"><span data-stu-id="01a88-108">As always with performance, it's important not to rush into optimization without data showing a problem; as the great Donald Knuth once said, "Premature optimization is the root of all evil".</span></span> <span data-ttu-id="01a88-109">Im Artikel [Leistungsdiagnose](xref:core/performance/performance-diagnosis) werden verschiedene Methoden erläutert, um herauszufinden, wo in der Datenbanklogik Ihre Anwendung Zeit verbringt und wie Sie bestimmte problematische Bereiche ermitteln können.</span><span class="sxs-lookup"><span data-stu-id="01a88-109">The [performance diagnosis](xref:core/performance/performance-diagnosis) section discusses various ways to understand where your application is spending time in database logic, and how to pinpoint specific problematic areas.</span></span> <span data-ttu-id="01a88-110">Wenn eine langsame Abfrage ermittelt wurde, kann die Lösungsfindung beginnen: Fehlt Ihrer Datenbank ein Index?</span><span class="sxs-lookup"><span data-stu-id="01a88-110">Once a slow query has been identified, solutions can be considered: is your database missing an index?</span></span> <span data-ttu-id="01a88-111">Sollten Sie andere Abfragemuster ausprobieren?</span><span class="sxs-lookup"><span data-stu-id="01a88-111">Should you try out other querying patterns?</span></span>

<span data-ttu-id="01a88-112">Legen Sie Codebenchmarks und mögliche Alternativen immer selbst fest. Der Artikel zur Leistungsdiagnose enthält einen Beispielvergleichstest mit BenchmarkDotNet, den Sie als Vorlage für Ihre eigenen Benchmarks verwenden können.</span><span class="sxs-lookup"><span data-stu-id="01a88-112">Always benchmark your code and possible alternatives yourself - the performance diagnosis section contains a sample benchmark with BenchmarkDotNet, which you can use as a template for your own benchmarks.</span></span> <span data-ttu-id="01a88-113">Gehen Sie nicht davon aus, dass allgemeine öffentliche Benchmarks unverändert auf Ihren speziellen Anwendungsfall angewendet werden können. Eine Vielzahl von Faktoren wie die Datenbanklatenz, die Abfragekomplexität und die tatsächlichen Datenmengen in Ihren Tabellen können sich maßgeblich darauf auswirken, welche Lösung die beste ist.</span><span class="sxs-lookup"><span data-stu-id="01a88-113">Don't assume that general, public benchmarks apply as-is to your specific use-case; a variety of factors such as database latency, query complexity and actual data amounts in your tables can have a profound effect on which solution is best.</span></span> <span data-ttu-id="01a88-114">Viele öffentliche Benchmarks werden z. B. unter idealen Netzwerkbedingungen, in denen die Latenzzeit zur Datenbank fast null beträgt, und mit extrem einfachen Abfragen ausgeführt, die kaum Verarbeitung (oder Datenträger-E/A) auf Datenbankseite erfordern.</span><span class="sxs-lookup"><span data-stu-id="01a88-114">For example, many public benchmarks are carried out in ideal networking conditions, where latency to the database is almost zero, and with extremely light queries which hardly require any processing (or disk I/O) on the database side.</span></span> <span data-ttu-id="01a88-115">Obwohl sie für den Vergleich des Mehraufwands zur Laufzeit, den verschiedene Datenzugriffsebenen aufweisen, von Bedeutung sind, sind die offengelegten Unterschiede in einer realen Anwendung, in der die Datenbank die tatsächliche Arbeit ausführt und die Latenz zur Datenbank ein bedeutender Leistungsfaktor ist, vernachlässigbar.</span><span class="sxs-lookup"><span data-stu-id="01a88-115">While these are valuable for comparing the runtime overheads of different data access layers, the differences they reveal usually prove to be negligible in a real-world application, where the database performs actual work and latency to the database is a significant perf factor.</span></span>

## <a name="aspects-of-data-access-performance"></a><span data-ttu-id="01a88-116">Aspekte der Datenzugriffsleistung</span><span class="sxs-lookup"><span data-stu-id="01a88-116">Aspects of data access performance</span></span>

<span data-ttu-id="01a88-117">Die gesamte Datenzugriffsleistung kann in die folgenden allgemeinen Kategorien aufgegliedert werden:</span><span class="sxs-lookup"><span data-stu-id="01a88-117">Overall data access performance can be broken down into the following broad categories:</span></span>

* <span data-ttu-id="01a88-118">**Reine Datenbankleistung:**</span><span class="sxs-lookup"><span data-stu-id="01a88-118">**Pure database performance**.</span></span> <span data-ttu-id="01a88-119">Bei relationalen Datenbanken übersetzt EF die LINQ-Abfragen der Anwendung in die SQL-Anweisungen, die von der Datenbank ausgeführt werden. Diese SQL-Anweisungen können mehr oder weniger effizient ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="01a88-119">With relational database, EF translates the application's LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently.</span></span> <span data-ttu-id="01a88-120">Der richtige Index an der richtigen Stelle kann beträchtliche Unterschiede in der SQL-Leistung hervorrufen. Auch das Neuschreiben Ihrer LINQ-Abfrage kann bewirken, dass EF eine bessere SQL-Abfrage generiert.</span><span class="sxs-lookup"><span data-stu-id="01a88-120">The right index in the right place can make a world of difference in SQL performance, or rewriting your LINQ query may make EF generate a better SQL query.</span></span>
* <span data-ttu-id="01a88-121">**Netzwerkdatenübertragung:**</span><span class="sxs-lookup"><span data-stu-id="01a88-121">**Network data transfer**.</span></span> <span data-ttu-id="01a88-122">Wie bei jedem Netzwerksystem ist es wichtig, die Datenmenge zu begrenzen, die bei der Übertragung hin und her gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="01a88-122">As with any networking system, it's important to limit the amount of data going back and forth on the wire.</span></span> <span data-ttu-id="01a88-123">Dadurch wird sichergestellt, dass Sie nur Daten senden und laden, die Sie tatsächlich benötigen, und beim Laden verwandter Entitäten den Effekt der sogenannten „kartesischen Explosion“ vermeiden.</span><span class="sxs-lookup"><span data-stu-id="01a88-123">This covers making sure that you only send and load data which you're actually going to need, but also avoiding the so-called "cartesian explosion" effect when loading related entities.</span></span>
* <span data-ttu-id="01a88-124">**Netzwerkroundtrips:**</span><span class="sxs-lookup"><span data-stu-id="01a88-124">**Network roundtrips**.</span></span> <span data-ttu-id="01a88-125">Abgesehen von der Datenmenge zählen auch die Netzwerkroundtrips, da die Zeit, die für die Ausführung einer Abfrage in der Datenbank benötigt wird, von der Zeit beeinflusst werden kann, die Pakete für die Übertragung zwischen Ihrer Anwendung und Ihrer Datenbank benötigen.</span><span class="sxs-lookup"><span data-stu-id="01a88-125">Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between your application and your database.</span></span> <span data-ttu-id="01a88-126">Der Roundtripmehraufwand hängt stark von Ihrer Umgebung ab. Je weiter entfernt der Datenbankserver ist, desto höher sind die Latenz und die Kosten für jeden Roundtrip.</span><span class="sxs-lookup"><span data-stu-id="01a88-126">Roundtrip overhead heavily depends on your environment; the further away your database server is, the high the latency and the costlier each roundtrip.</span></span> <span data-ttu-id="01a88-127">Seit der Einführung der Cloud sind Anwendungen zunehmend weiter von der Datenbank entfernt, und kommunikationsintensive Anwendungen, die zu viele Roundtrips ausführen, weisen eine schlechtere Leistung auf.</span><span class="sxs-lookup"><span data-stu-id="01a88-127">With the advent of the cloud, applications increasingly find themselves further away from the database, and "chatty" applications which perform too many roundtrips experience degraded performance.</span></span> <span data-ttu-id="01a88-128">Daher ist es wichtig, genau zu verstehen, wann Ihre Anwendung die Datenbank kontaktiert, wie viele Roundtrips sie ausführt und ob diese Zahl minimiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="01a88-128">Therefore, it's important to understand exactly when your application contacts the database, how many roundtrips it performs, and whether that number can be minimized them.</span></span>
* <span data-ttu-id="01a88-129">**EF-Mehraufwand zur Laufzeit:**</span><span class="sxs-lookup"><span data-stu-id="01a88-129">**EF runtime overhead**.</span></span> <span data-ttu-id="01a88-130">Schließlich führt EF selbst zu einem zusätzlichen Laufzeitmehraufwand für Datenbankvorgänge: EF muss Ihre Abfragen aus LINQ in SQL kompilieren (obwohl dies normalerweise nur einmal erfolgen sollte), die Änderungsnachverfolgung ruft ebenfalls einen gewissen Mehraufwand hervor (kann jedoch deaktiviert werden) usw. In der Praxis ist der Mehraufwand von EF für reale Anwendungen oftmals wahrscheinlich unerheblich, da die Gesamtzeit vornehmlich von der Ausführungszeit der Abfragen in der Datenbank und der Netzwerklatenz abhängt. Es ist jedoch wichtig zu verstehen, wie Ihre Optionen lauten und wie Sie einige Fehler vermeiden können.</span><span class="sxs-lookup"><span data-stu-id="01a88-130">Finally, EF itself adds some runtime overhead to database operations: EF needs to compile your queries from LINQ to SQL (although that should normally be done only once), change tracking adds some overhead (but can be disabled), etc. In practice, the EF overhead for real-world applications is likely to be negligible in most cases, as query execution time in the database and network latency dominate the total time; but it's important to understand what your options are and how to avoid some pitfalls.</span></span>

## <a name="know-whats-happening-under-the-hood"></a><span data-ttu-id="01a88-131">Abläufe unter der Haube</span><span class="sxs-lookup"><span data-stu-id="01a88-131">Know what's happening under the hood</span></span>

<span data-ttu-id="01a88-132">EF ermöglicht es Entwicklern, sich auf die Geschäftslogik zu konzentrieren, indem SQL erstellt wird und Ergebnisse materialisiert sowie andere Aufgaben durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="01a88-132">EF allows developers to concentrate on business logic by generating SQL, materializing results, and performing other tasks.</span></span> <span data-ttu-id="01a88-133">Wie jede andere Ebene oder Abstraktion wird tendenziell verborgen, was unter der Haube geschieht, z. B. die tatsächlichen SQL-Abfragen, die gerade ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="01a88-133">Like any layer or abstraction, it also tends to hide what's happening under-the-hood, such as the actual SQL queries being executed.</span></span> <span data-ttu-id="01a88-134">Die Leistung ist nicht in allen Anwendungen notwendigerweise ein kritischer Aspekt. In den Anwendungen, in denen dies der Fall ist, ist es jedoch von entscheidender Bedeutung, dass der Entwickler versteht, welche Vorteile EF bietet: Überprüfen von ausgehenden SQL-Abfragen, Verfolgen von Roundtrips zum Sicherstellen, dass das N+1-Problem nicht auftritt usw.</span><span class="sxs-lookup"><span data-stu-id="01a88-134">Performance isn't necessarily a critical aspect of every application out there, but in applications where it is, it is vital that the developer understand what EF is doing for them: inspect outgoing SQL queries, follow roundtrips to make sure the N+1 problem isn't occurring, etc.</span></span>

## <a name="cache-outside-the-database"></a><span data-ttu-id="01a88-135">Zwischenspeichern außerhalb der Datenbank</span><span class="sxs-lookup"><span data-stu-id="01a88-135">Cache outside the database</span></span>

<span data-ttu-id="01a88-136">Die effizienteste Methode für die Interaktion mit einer Datenbank besteht darin, überhaupt nicht mit ihr zu interagieren.</span><span class="sxs-lookup"><span data-stu-id="01a88-136">Finally, the most efficient way to interact with a database, is to not interact with it at all.</span></span> <span data-ttu-id="01a88-137">Anders ausgedrückt: Wenn der Datenbankzugriff als Leistungsengpass in der Anwendung angezeigt wird, kann es sinnvoll sein, bestimmte Ergebnisse außerhalb der Datenbank zwischenzuspeichern, um die Anforderungen zu minimieren.</span><span class="sxs-lookup"><span data-stu-id="01a88-137">In other words, if database access shows up as a performance bottleneck in your application, it may be worthwhile to cache certain results outside of the database, so as to minimize requests.</span></span> <span data-ttu-id="01a88-138">Obwohl das Zwischenspeichern die Komplexität steigert, ist es ein besonders wesentlicher Bestandteil jeder skalierbaren Anwendung: Während die Logikschicht durch Hinzufügen zusätzlicher Server, die eine höhere Auslastung bewältigen, problemlos skaliert werden kann, ist eine Skalierung der Datenbankschicht meist weitaus komplizierter.</span><span class="sxs-lookup"><span data-stu-id="01a88-138">Although caching adds complexity, it is an especially crucial part of any scalable application: while the application tier can be easy scaled by adding additional servers to handle increased load, scaling the database tier is usually far more complicated.</span></span>
