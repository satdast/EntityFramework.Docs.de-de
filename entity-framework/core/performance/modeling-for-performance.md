---
title: Modellierung für Leistungs EF Core
description: Effizientes modellieren bei Verwendung Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: fc16ec67c3865aa7b7a95519463ca7493a2709b0
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657729"
---
# <a name="modeling-for-performance"></a><span data-ttu-id="78b55-103">Modellieren der Leistung</span><span class="sxs-lookup"><span data-stu-id="78b55-103">Modeling for Performance</span></span>

<span data-ttu-id="78b55-104">In vielen Fällen kann die Art und Weise, wie Sie modellieren, eine tiefgreifende Auswirkung auf die Leistung der Anwendung haben. ein ordnungsgemäß normalisiertes und "korrektes" Modell ist in der Regel ein guter Ausgangspunkt, aber in realen Anwendungen können einige pragmatische Kompromisse eine gute Leistung erzielen.</span><span class="sxs-lookup"><span data-stu-id="78b55-104">In many cases, the way you model can have a profound impact on the performance of your application; while a properly normalized and "correct" model is usually a good starting point, in real-world applications some pragmatic compromises can go a long way for achieving good performance.</span></span> <span data-ttu-id="78b55-105">Da es ziemlich schwierig ist, das Modell zu ändern, sobald eine Anwendung in der Produktion ausgeführt wird, sollten Sie die Leistung beim Erstellen des anfänglichen Modells berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="78b55-105">Since it's quite difficult to change your model once an application is running in production, it's worth keeping performance in mind when creating the initial model.</span></span>

## <a name="denormalization-and-caching"></a><span data-ttu-id="78b55-106">Denormalisierung und Caching</span><span class="sxs-lookup"><span data-stu-id="78b55-106">Denormalization and caching</span></span>

<span data-ttu-id="78b55-107">*Denormalization* ist die Vorgehensweise, dem Schema redundante Daten hinzuzufügen, in der Regel, um Joins bei Abfragen auszuschließen.</span><span class="sxs-lookup"><span data-stu-id="78b55-107">*Denormalization* is the practice of adding redundant data to your schema, usually in order to eliminate joins when querying.</span></span> <span data-ttu-id="78b55-108">Beispielsweise müssen Sie für ein Modell mit Blogs und Beiträgen, in denen jeder Beitrag eine Bewertung hat, häufig die durchschnittliche Bewertung des Blogs anzeigen.</span><span class="sxs-lookup"><span data-stu-id="78b55-108">For example, for a model with Blogs and Posts, where each Post has a Rating, you may be required to frequently show the average rating of the Blog.</span></span> <span data-ttu-id="78b55-109">Die einfache Vorgehensweise würde die Beiträge nach Ihrem Blog gruppieren und den Durchschnitt als Teil der Abfrage berechnen. dafür ist jedoch ein kostspieliger Join zwischen den beiden Tabellen erforderlich.</span><span class="sxs-lookup"><span data-stu-id="78b55-109">The simple approach to this would group the Posts by their Blog, and calculate the average as part of the query; but this requires a costly join between the two tables.</span></span> <span data-ttu-id="78b55-110">Die Denormalisierung würde den berechneten Durchschnitt aller Beiträge zu einer neuen Spalte im Blog hinzufügen, sodass Sie sofort zugänglich ist, ohne zu beitreten oder zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="78b55-110">Denormalization would add the calculated average of all posts to a new column on Blog, so that it is immediately accessible, without joining or calculating.</span></span>

<span data-ttu-id="78b55-111">Die *oben genannten können als Form der zwischen* Speicherung angezeigt werden: aggregierte Informationen aus den Beiträgen werden in Ihrem Blog zwischengespeichert. ebenso wie bei jedem Caching besteht das Problem darin, dass der zwischengespeicherte Wert mit den Daten, die zwischengespeichert werden, auf dem neuesten Stand gehalten wird.</span><span class="sxs-lookup"><span data-stu-id="78b55-111">The above can be viewed as a form of *caching* - aggregate information from the Posts is cached on their Blog; and like with any caching, the problem is how to keep the cached value up to date with the data it's caching.</span></span> <span data-ttu-id="78b55-112">In vielen Fällen ist es in Ordnung, dass die zwischengespeicherten Daten für ein wenig verzögert werden. im obigen Beispiel ist es in der Regel sinnvoll, dass die durchschnittliche Bewertung des Blogs an einem bestimmten Punkt nicht vollständig auf dem neuesten Stand ist.</span><span class="sxs-lookup"><span data-stu-id="78b55-112">In many cases, it's OK for the cached data to lag for a bit; for example, in the example above, it's usually reasonable for the blog's average rating to not be completely up to date at any given point.</span></span> <span data-ttu-id="78b55-113">Wenn dies der Fall ist, können Sie die Anwendung jetzt alle und dann neu berechnen. Andernfalls muss ein aufwendiges System eingerichtet werden, damit die zwischengespeicherten Werte auf dem neuesten Stand gehalten werden.</span><span class="sxs-lookup"><span data-stu-id="78b55-113">If that's the case, you can have it recalculated every now and then; otherwise, a more elaborate system must be set up to keep the cached values up to date.</span></span>

<span data-ttu-id="78b55-114">Im folgenden werden einige Verfahren für Denormalisierung und Caching in EF Core erläutert und auf die relevanten Abschnitte in der-Dokumentation verwiesen.</span><span class="sxs-lookup"><span data-stu-id="78b55-114">The following details some techniques for denormalization and caching in EF Core, and points to the relevant sections in the documentation.</span></span>

### <a name="stored-computed-columns"></a><span data-ttu-id="78b55-115">Gespeicherte berechnete Spalten</span><span class="sxs-lookup"><span data-stu-id="78b55-115">Stored computed columns</span></span>

<span data-ttu-id="78b55-116">Wenn die zwischengespeicherten Daten ein Produkt anderer Spalten in der gleichen Tabelle sind, kann eine [gespeicherte berechnete Spalte](xref:core/modeling/generated-properties#computed-columns) eine perfekte Lösung sein.</span><span class="sxs-lookup"><span data-stu-id="78b55-116">If the data to be cached is a product of other columns in the same table, then a [stored computed column](xref:core/modeling/generated-properties#computed-columns) can be a perfect solution.</span></span> <span data-ttu-id="78b55-117">Beispielsweise kann eine `Customer` `FirstName` -Spalte und eine- `LastName` Spalte enthalten, aber wir müssen möglicherweise nach dem *vollständigen Namen* des Kunden suchen.</span><span class="sxs-lookup"><span data-stu-id="78b55-117">For example, a `Customer` may have `FirstName` and `LastName` columns, but we may need to search by the customer's *full name*.</span></span> <span data-ttu-id="78b55-118">Eine gespeicherte berechnete Spalte wird automatisch von der Datenbank verwaltet. diese wird immer neu berechnet, wenn die Zeile geändert wird, und Sie können sogar einen Index darüber definieren, um Abfragen zu beschleunigen.</span><span class="sxs-lookup"><span data-stu-id="78b55-118">A stored computed column is automatically maintained by the database - which recalculates it whenever the row is changed - and you can even define an index over it to speed up queries.</span></span>

### <a name="update-cache-columns-when-inputs-change"></a><span data-ttu-id="78b55-119">Aktualisieren von Cache Spalten bei Änderung von Eingaben</span><span class="sxs-lookup"><span data-stu-id="78b55-119">Update cache columns when inputs change</span></span>

<span data-ttu-id="78b55-120">Wenn die zwischengespeicherte Spalte auf Eingaben von außerhalb der Tabellenzeile verweisen muss, können keine berechneten Spalten verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="78b55-120">If your cached column needs to reference inputs from outside the table's row, you cannot use computed columns.</span></span> <span data-ttu-id="78b55-121">Es ist jedoch immer noch möglich, die Spalte neu zu berechnen, wenn die Eingabe geändert wird. Beispielsweise können Sie die Bewertung des durchschnittlichen Blogs jedes Mal neu berechnen, wenn ein Beitrag geändert, hinzugefügt oder entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="78b55-121">However, it is still possible to recalculate the column whenever its input changes; for example, you could recalculate the average Blog's rating every time a Post is changed, added or removed.</span></span> <span data-ttu-id="78b55-122">Achten Sie darauf, die genauen Bedingungen zu identifizieren, wenn eine Neuberechnung erforderlich ist. andernfalls wird der zwischengespeicherte Wert nicht mehr synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="78b55-122">Be sure to identify the exact conditions when recalculation is needed, otherwise your cached value will go out of sync.</span></span>

<span data-ttu-id="78b55-123">Eine Möglichkeit besteht darin, das Update selbst über die reguläre EF Core-API auszuführen.</span><span class="sxs-lookup"><span data-stu-id="78b55-123">One way to do this, is to perform the update yourself, via the regular EF Core API.</span></span> <span data-ttu-id="78b55-124">`SaveChanges`[Ereignisse](xref:core/logging-events-diagnostics/events) oder [Interceptors](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) können verwendet werden, um automatisch zu überprüfen, ob Beiträge aktualisiert werden, und um die Neuberechnung auf diese Weise auszuführen.</span><span class="sxs-lookup"><span data-stu-id="78b55-124">`SaveChanges` [Events](xref:core/logging-events-diagnostics/events) or [interceptors](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) can be used to automatically check if any Posts are being updated, and to perform the recalculation that way.</span></span> <span data-ttu-id="78b55-125">Beachten Sie, dass dies in der Regel zusätzliche Datenbankroundtrips umfasst, da zusätzliche Befehle gesendet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="78b55-125">Note that this typically entails additional database roundtrips, as additional commands must be sent.</span></span>

<span data-ttu-id="78b55-126">Bei größeren Leistungs sensitiven Anwendungen können Daten Bank Trigger definiert werden, um die Neuberechnung in der Datenbank automatisch auszuführen.</span><span class="sxs-lookup"><span data-stu-id="78b55-126">For more perf-sensitive applications, database triggers can be defined to automatically perform the recalculation in the database.</span></span> <span data-ttu-id="78b55-127">Dadurch werden zusätzliche Datenbankroundtrips eingespart, die automatisch innerhalb der gleichen Transaktion wie das Haupt Update ausgeführt werden, und es kann einfacher eingerichtet werden.</span><span class="sxs-lookup"><span data-stu-id="78b55-127">This saves the extra database roundtrips, automatically occurs within the same transaction as the main update, and can be simpler to set up.</span></span> <span data-ttu-id="78b55-128">EF bietet keine bestimmte API zum Erstellen oder Verwalten von Triggern, aber es ist ganz schön, [eine leere Migration zu erstellen und die Triggerdefinition über RAW SQL hinzuzufügen](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span><span class="sxs-lookup"><span data-stu-id="78b55-128">EF doesn't provide any specific API for creating or maintaining triggers, but it's perfectly fine to [create an empty migration and add the trigger definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

### <a name="materialized-views"></a><span data-ttu-id="78b55-129">Materialisierte Sichten</span><span class="sxs-lookup"><span data-stu-id="78b55-129">Materialized views</span></span>

<span data-ttu-id="78b55-130">Materialisierte Sichten ähneln regulären Sichten, mit dem Unterschied, dass Ihre Daten auf dem Datenträger ("MATERIALIZED") gespeichert werden und nicht jedes Mal berechnet werden, wenn die Sicht abgefragt wird.</span><span class="sxs-lookup"><span data-stu-id="78b55-130">Materialized views are similar to regular views, except that their data is stored on disk ("materialized"), rather than calculated every time when the view is queried.</span></span> <span data-ttu-id="78b55-131">Dieses Tool ist nützlich, wenn Sie einer vorhandenen Datenbank nicht einfach eine einzelne Cache Spalte hinzufügen möchten, sondern den gesamten Resultset der Ergebnisse komplexer und kostspieliger Abfragen so speichern möchten, als ob es sich um eine reguläre Tabelle handelt. Diese Ergebnisse können dann sehr kostengünstig abgefragt werden, ohne dass Berechnungen oder Joins ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="78b55-131">This tool is useful when you don't want to simply add a single cache column to an existing database, but rather want to cache the entire resultset of a complicated and expensive query's results, just as if it were a regular table; these results can then be queried very cheaply without any computation or joins happening.</span></span> <span data-ttu-id="78b55-132">Im Gegensatz zu berechneten Spalten werden materialisierte Sichten nicht automatisch aktualisiert, wenn sich die zugrunde liegenden Tabellen ändern. Sie müssen manuell aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="78b55-132">Unlike computed columns, materialized views aren't automatically updated when their underlying tables change - they must be manually refreshed.</span></span> <span data-ttu-id="78b55-133">Wenn die zwischengespeicherten Daten verzögert werden können, kann das Aktualisieren der Ansicht über einen Timer erfolgen. eine andere Möglichkeit besteht darin, Daten Bank Trigger so einzurichten, dass eine materialisierte Sicht nach bestimmten Daten Bank Ereignissen überprüft wird.</span><span class="sxs-lookup"><span data-stu-id="78b55-133">If the cached data can lag, refreshing the view can be done via a timer; another option is to set up database triggers to review a materialized view once certain database events occur.</span></span>

<span data-ttu-id="78b55-134">EF stellt derzeit keine bestimmte API zum Erstellen oder Verwalten von Sichten bereit, materialisiert oder anderweitig; Es ist jedoch ganz schön, [eine leere Migration zu erstellen und die Sicht Definition über RAW SQL hinzuzufügen](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span><span class="sxs-lookup"><span data-stu-id="78b55-134">EF doesn't currently provide any specific API for creating or maintaining views, materialized or otherwise; but it's perfectly fine to [create an empty migration and add the view definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

## <a name="inheritance-mapping"></a><span data-ttu-id="78b55-135">Vererbungs Zuordnung</span><span class="sxs-lookup"><span data-stu-id="78b55-135">Inheritance mapping</span></span>

<span data-ttu-id="78b55-136">Es wird empfohlen, [die dedizierte Seite zur Vererbung](xref:core/modeling/inheritance) zu lesen, bevor Sie mit diesem Abschnitt fortfahren.</span><span class="sxs-lookup"><span data-stu-id="78b55-136">It's recommended to read [the dedicated page on inheritance](xref:core/modeling/inheritance) before continuing with this section.</span></span>

<span data-ttu-id="78b55-137">EF Core unterstützt derzeit zwei Verfahren zum Mapping eines Vererbungs Modells zu einer relationalen Datenbank:</span><span class="sxs-lookup"><span data-stu-id="78b55-137">EF Core currently supports two techniques for mapping an inheritance model to a relational database:</span></span>

* <span data-ttu-id="78b55-138">**Tabelle pro Hierarchie** (TPH), in der eine gesamte .net-Hierarchie von Klassen einer einzelnen Datenbanktabelle zugeordnet wird</span><span class="sxs-lookup"><span data-stu-id="78b55-138">**Table-per-hierarchy** (TPH), in which an entire .NET hierarchy of classes is mapped to a single database table</span></span>
* <span data-ttu-id="78b55-139">**Tabelle pro Typ** (TPT), in der jeder Typ in der .net-Hierarchie einer anderen Tabelle in der Datenbank zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="78b55-139">**Table-per-type** (TPT), in which each type in the .NET hierarchy is mapped to a different table in the database.</span></span>

<span data-ttu-id="78b55-140">Die Auswahl der Methode für die Vererbung von Vererbung kann eine beträchtliche Auswirkung auf die Anwendungsleistung haben. es wird empfohlen, vor dem Commit auf eine Auswahl sorgfältig zu messen.</span><span class="sxs-lookup"><span data-stu-id="78b55-140">The choice of inheritance mapping technique can have a considerable impact on application performance - it's recommended to carefully measure before committing to a choice.</span></span>

<span data-ttu-id="78b55-141">Manchmal wählen Sie TPT aus, da es sich anscheinend um die "saubere" Methode handelt. eine separate Tabelle für jeden .NET-Typ bewirkt, dass das Datenbankschema der .net-Typhierarchie ähnelt.</span><span class="sxs-lookup"><span data-stu-id="78b55-141">People sometimes choose TPT because it appears to be the "cleaner" technique; a separate table for each .NET type makes the database schema look similar to the .NET type hierarchy.</span></span> <span data-ttu-id="78b55-142">Da TPH die gesamte Hierarchie in einer einzelnen Tabelle darstellen muss, verfügen die Zeilen darüber hinaus über *alle* Spalten, unabhängig vom Typ, der tatsächlich in der Zeile gespeichert ist, und nicht verknüpfte Spalten sind immer leer und werden nicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="78b55-142">In addition, since TPH must represent the entire hierarchy in a single table, rows have *all* columns regardless of the type actually being held in the row, and unrelated columns are always empty and unused.</span></span> <span data-ttu-id="78b55-143">Abgesehen davon, dass es sich um ein unreines Zuordnungs Verfahren handelt, sind viele davon überzeugt, dass diese leeren Spalten beträchtlichen Speicherplatz in der Datenbank beanspruchen und die Leistung beeinträchtigen können.</span><span class="sxs-lookup"><span data-stu-id="78b55-143">Aside from seeming to be an "unclean" mapping technique, many believe that these empty columns take up considerable space in the database and may hurt performance as well.</span></span>

<span data-ttu-id="78b55-144">Die Messung zeigt jedoch, dass TPT in den meisten Fällen die unterste Karten Methode aus Leistungs Sicht verwendet. Wenn alle Daten in TPH aus einer einzelnen Tabelle stammen, müssen TPT-Abfragen mehrere Tabellen miteinander verknüpfen, und Joins sind eine der primären Quellen für Leistungsprobleme in relationalen Datenbanken.</span><span class="sxs-lookup"><span data-stu-id="78b55-144">However, measuring shows that TPT is in most cases the inferior mapping technique from a performance standpoint; where all data in TPH comes from a single table, TPT queries must join together multiple tables, and joins are one of the primary sources of performance issues in relational databases.</span></span> <span data-ttu-id="78b55-145">Datenbanken neigen in der Regel auch zu leeren Spalten, und Features wie [SQL Server sparsespalten](/sql/relational-databases/tables/use-sparse-columns) können diesen Aufwand noch weiter reduzieren.</span><span class="sxs-lookup"><span data-stu-id="78b55-145">Databases also generally tend to deal well with empty columns, and features such as [SQL Server sparse columns](/sql/relational-databases/tables/use-sparse-columns) can reduce this overhead even further.</span></span>

<span data-ttu-id="78b55-146">Ein konkretes Beispiel finden Sie unter [diesem Benchmarkwert](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) , mit dem ein einfaches Modell mit einer Hierarchie von 7 Typen eingerichtet wird. 5000 Zeilen werden für jeden Typ mit der Grundlage von 35000 Zeilen in einem Seeding angezeigt, und der Vergleichstest lädt einfach alle Zeilen aus der Datenbank:</span><span class="sxs-lookup"><span data-stu-id="78b55-146">For a concrete example, [see this benchmark](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) which sets up a simple model with a 7-type hierarchy; 5000 rows are seeded for each type - totalling 35000 rows - and the benchmark simply loads all rows from the database:</span></span>

| <span data-ttu-id="78b55-147">Methode</span><span class="sxs-lookup"><span data-stu-id="78b55-147">Method</span></span> |     <span data-ttu-id="78b55-148">Mittelwert</span><span class="sxs-lookup"><span data-stu-id="78b55-148">Mean</span></span> |   <span data-ttu-id="78b55-149">Fehler</span><span class="sxs-lookup"><span data-stu-id="78b55-149">Error</span></span> |  <span data-ttu-id="78b55-150">StdDev</span><span class="sxs-lookup"><span data-stu-id="78b55-150">StdDev</span></span> |     <span data-ttu-id="78b55-151">Gen 0</span><span class="sxs-lookup"><span data-stu-id="78b55-151">Gen 0</span></span> |     <span data-ttu-id="78b55-152">Gen 1</span><span class="sxs-lookup"><span data-stu-id="78b55-152">Gen 1</span></span> |     <span data-ttu-id="78b55-153">Gen 2</span><span class="sxs-lookup"><span data-stu-id="78b55-153">Gen 2</span></span> | <span data-ttu-id="78b55-154">Zugeordnet</span><span class="sxs-lookup"><span data-stu-id="78b55-154">Allocated</span></span> |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    <span data-ttu-id="78b55-155">TPH</span><span class="sxs-lookup"><span data-stu-id="78b55-155">TPH</span></span> | <span data-ttu-id="78b55-156">132,3 ms</span><span class="sxs-lookup"><span data-stu-id="78b55-156">132.3 ms</span></span> | <span data-ttu-id="78b55-157">2,29 ms</span><span class="sxs-lookup"><span data-stu-id="78b55-157">2.29 ms</span></span> | <span data-ttu-id="78b55-158">2,03 MS</span><span class="sxs-lookup"><span data-stu-id="78b55-158">2.03 ms</span></span> | <span data-ttu-id="78b55-159">8000,0000</span><span class="sxs-lookup"><span data-stu-id="78b55-159">8000.0000</span></span> | <span data-ttu-id="78b55-160">3000,0000</span><span class="sxs-lookup"><span data-stu-id="78b55-160">3000.0000</span></span> | <span data-ttu-id="78b55-161">1250,0000</span><span class="sxs-lookup"><span data-stu-id="78b55-161">1250.0000</span></span> |  <span data-ttu-id="78b55-162">44,49 MB</span><span class="sxs-lookup"><span data-stu-id="78b55-162">44.49 MB</span></span> |
|    <span data-ttu-id="78b55-163">TPT</span><span class="sxs-lookup"><span data-stu-id="78b55-163">TPT</span></span> | <span data-ttu-id="78b55-164">201,3 ms</span><span class="sxs-lookup"><span data-stu-id="78b55-164">201.3 ms</span></span> | <span data-ttu-id="78b55-165">3,32 MS</span><span class="sxs-lookup"><span data-stu-id="78b55-165">3.32 ms</span></span> | <span data-ttu-id="78b55-166">3,10 ms</span><span class="sxs-lookup"><span data-stu-id="78b55-166">3.10 ms</span></span> | <span data-ttu-id="78b55-167">9000,0000</span><span class="sxs-lookup"><span data-stu-id="78b55-167">9000.0000</span></span> | <span data-ttu-id="78b55-168">4000,0000</span><span class="sxs-lookup"><span data-stu-id="78b55-168">4000.0000</span></span> |         - |  <span data-ttu-id="78b55-169">61,84 MB</span><span class="sxs-lookup"><span data-stu-id="78b55-169">61.84 MB</span></span> |

<span data-ttu-id="78b55-170">Wie Sie sehen können, ist TPH deutlich effizienter als TPT für dieses Szenario.</span><span class="sxs-lookup"><span data-stu-id="78b55-170">As can be seen, TPH is considerably more efficient than TPT for this scenario.</span></span> <span data-ttu-id="78b55-171">Beachten Sie, dass die tatsächlichen Ergebnisse immer von der bestimmten ausgeführten Abfrage und der Anzahl der Tabellen in der Hierarchie abhängen, sodass andere Abfragen möglicherweise eine andere Leistungslücke darstellen. Es wird empfohlen, diesen Vergleichs Code als Vorlage zum Testen anderer Abfragen zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="78b55-171">Note that actual results always depend on the specific query being executed and the number of tables in the hierarchy, so other queries may show a different performance gap; you're encouraged to use this benchmark code as a template for testing other queries.</span></span>
