---
title: 'Abfragen mit Nachverfolgung im Vergleich zu Abfragen ohne Nachverfolgung: EF Core'
description: Informationen zu Abfragen mit und ohne Nachverfolgung in Entity Framework Core
author: smitpatel
ms.date: 11/09/2020
uid: core/querying/tracking
ms.openlocfilehash: cb18125fb3453bb533981afb36480b12727cd6f2
ms.sourcegitcommit: 7700840119b1639275f3b64836e7abb59103f2e7
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/28/2021
ms.locfileid: "98983416"
---
# <a name="tracking-vs-no-tracking-queries"></a><span data-ttu-id="84a8d-103">Abfragen mit Nachverfolgung im Vergleich zu Abfragen ohne Nachverfolgung</span><span class="sxs-lookup"><span data-stu-id="84a8d-103">Tracking vs. No-Tracking Queries</span></span>

<span data-ttu-id="84a8d-104">Das Nachverfolgungsverhalten steuert, ob Entity Framework Core Informationen über eine Entitätsinstanz in der Änderungsprotokollierung speichert.</span><span class="sxs-lookup"><span data-stu-id="84a8d-104">Tracking behavior controls if Entity Framework Core will keep information about an entity instance in its change tracker.</span></span> <span data-ttu-id="84a8d-105">Wenn eine Entität nachverfolgt wird, werden alle Änderungen, die in der Entität erkannt werden, während `SaveChanges()` in der Datenbank beibehalten.</span><span class="sxs-lookup"><span data-stu-id="84a8d-105">If an entity is tracked, any changes detected in the entity will be persisted to the database during `SaveChanges()`.</span></span> <span data-ttu-id="84a8d-106">EF Core korrigiert auch Unstimmigkeiten zwischen den Navigationseigenschaften von Entitäten in einem Nachverfolgungs-Abfrageergebnis und Entitäten, die sich in der Änderungsprotokollierung befinden.</span><span class="sxs-lookup"><span data-stu-id="84a8d-106">EF Core will also fix up navigation properties between the entities in a tracking query result and the entities that are in the change tracker.</span></span>

> [!NOTE]
> <span data-ttu-id="84a8d-107">[Schlüssellose Entitätstypen](xref:core/modeling/keyless-entity-types) werden nie nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-107">[Keyless entity types](xref:core/modeling/keyless-entity-types) are never tracked.</span></span> <span data-ttu-id="84a8d-108">Wenn in diesem Artikel Entitätstypen erwähnt werden, sind Entitätstypen gemeint, für die ein Schlüssel definiert ist.</span><span class="sxs-lookup"><span data-stu-id="84a8d-108">Wherever this article mentions entity types, it refers to entity types which have a key defined.</span></span>

> [!TIP]
> <span data-ttu-id="84a8d-109">Das in diesem Artikel verwendete [Beispiel](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/Tracking) finden Sie auf GitHub.</span><span class="sxs-lookup"><span data-stu-id="84a8d-109">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/Tracking) on GitHub.</span></span>

## <a name="tracking-queries"></a><span data-ttu-id="84a8d-110">Abfragen mit Nachverfolgung</span><span class="sxs-lookup"><span data-stu-id="84a8d-110">Tracking queries</span></span>

<span data-ttu-id="84a8d-111">Abfragen, die Entitätstypen zurückgeben, verfügen standardmäßig über Nachverfolgung.</span><span class="sxs-lookup"><span data-stu-id="84a8d-111">By default, queries that return entity types are tracking.</span></span> <span data-ttu-id="84a8d-112">Das bedeutet, Sie können Änderungen an diesen Entitätsinstanzen vornehmen, und diese Änderungen werden von `SaveChanges()` beibehalten.</span><span class="sxs-lookup"><span data-stu-id="84a8d-112">Which means you can make changes to those entity instances and have those changes persisted by `SaveChanges()`.</span></span> <span data-ttu-id="84a8d-113">Im folgenden Beispiel wird die Änderung an der Bewertung des Blogs erkannt und während `SaveChanges()` in der Datenbank beibehalten.</span><span class="sxs-lookup"><span data-stu-id="84a8d-113">In the following example, the change to the blogs rating will be detected and persisted to the database during `SaveChanges()`.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#Tracking)]

<span data-ttu-id="84a8d-114">Wenn die Ergebnisse in einer Abfrage mit Nachverfolgung zurückgegeben werden, prüft EF Core, ob die Entität bereits im Kontext ist.</span><span class="sxs-lookup"><span data-stu-id="84a8d-114">When the results are returned in a tracking query, EF Core will check if the entity is already in the context.</span></span> <span data-ttu-id="84a8d-115">Wenn EF Core eine vorhandene Entität findet, wird dieselbe Instanz zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="84a8d-115">If EF Core finds an existing entity, then the same instance is returned.</span></span> <span data-ttu-id="84a8d-116">EF Core überschreibt im Eintrag mit den Datenbankwerten nicht die aktuellen und ursprünglichen Werte der Eigenschaften der Entität.</span><span class="sxs-lookup"><span data-stu-id="84a8d-116">EF Core won't overwrite current and original values of the entity's properties in the entry with the database values.</span></span> <span data-ttu-id="84a8d-117">Wenn die Entität nicht im Kontext gefunden wird, erstellt EF Core eine neue Entitätsinstanz und fügt sie dem Kontext an.</span><span class="sxs-lookup"><span data-stu-id="84a8d-117">If the entity isn't found in the context, then EF Core will create a new entity instance and attach it to the context.</span></span> <span data-ttu-id="84a8d-118">Abfrageergebnisse enthalten keine Entität, die dem Kontext hinzugefügt, aber noch nicht in der Datenbank gespeichert wurde.</span><span class="sxs-lookup"><span data-stu-id="84a8d-118">Query results don't contain any entity, which is added to the context but not yet saved to the database.</span></span>

## <a name="no-tracking-queries"></a><span data-ttu-id="84a8d-119">Abfragen ohne Nachverfolgung</span><span class="sxs-lookup"><span data-stu-id="84a8d-119">No-tracking queries</span></span>

<span data-ttu-id="84a8d-120">Abfragen ohne Nachverfolgung sind nützlich, wenn die Ergebnisse in einem schreibgeschützten Szenario verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="84a8d-120">No tracking queries are useful when the results are used in a read-only scenario.</span></span> <span data-ttu-id="84a8d-121">Sie werden schneller ausgeführt, da keine Informationen für die Änderungsnachverfolgung eingerichtet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="84a8d-121">They're quicker to execute because there's no need to set up the change tracking information.</span></span> <span data-ttu-id="84a8d-122">Wenn Sie die aus der Datenbank abgerufenen Entitäten nicht aktualisieren müssen, sollte eine Abfrage ohne Nachverfolgung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="84a8d-122">If you don't need to update the entities retrieved from the database, then a no-tracking query should be used.</span></span> <span data-ttu-id="84a8d-123">Sie können eine einzelne Abfrage ändern, sodass sie keine Nachverfolgung ausführt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-123">You can swap an individual query to be no-tracking.</span></span> <span data-ttu-id="84a8d-124">Keine Abfrage mit Nachverfolgung liefert Ihnen zudem Ergebnisse, die auf dem Inhalt der Datenbank basieren, wobei lokale Änderungen oder hinzugefügte Entitäten unberücksichtigt bleiben.</span><span class="sxs-lookup"><span data-stu-id="84a8d-124">No tracking query will also give you results based on what is in the database disregarding any local changes or added entities.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTracking)]

<span data-ttu-id="84a8d-125">Sie können das Standardnachverfolgungsverhalten auch auf der Ebene der Kontextinstanz ändern:</span><span class="sxs-lookup"><span data-stu-id="84a8d-125">You can also change the default tracking behavior at the context instance level:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ContextDefaultTrackingBehavior)]

## <a name="identity-resolution"></a><span data-ttu-id="84a8d-126">Identitätsauflösung</span><span class="sxs-lookup"><span data-stu-id="84a8d-126">Identity resolution</span></span>

<span data-ttu-id="84a8d-127">Da eine Nachverfolgungsabfrage die Änderungsprotokollierung verwendet, führt EF Core in einer Nachverfolgungsabfrage eine Identitätsauflösung durch.</span><span class="sxs-lookup"><span data-stu-id="84a8d-127">Since a tracking query uses the change tracker, EF Core will do identity resolution in a tracking query.</span></span> <span data-ttu-id="84a8d-128">Beim Materialisieren einer Entität gibt EF Core dieselbe Entitätsinstanz aus der Änderungsprotokollierung zurück, wenn sie bereits nachverfolgt wird.</span><span class="sxs-lookup"><span data-stu-id="84a8d-128">When materializing an entity, EF Core will return the same entity instance from the change tracker if it's already being tracked.</span></span> <span data-ttu-id="84a8d-129">Wenn das Ergebnis mehrmals dieselbe Entität enthält, erhalten Sie für jedes Vorkommen dieselbe Instanz.</span><span class="sxs-lookup"><span data-stu-id="84a8d-129">If the result contains the same entity multiple times, you get back same instance for each occurrence.</span></span> <span data-ttu-id="84a8d-130">Abfragen ohne Nachverfolgung verwenden weder die Änderungsprotokollierung, noch führen sie eine Identitätsauflösung durch.</span><span class="sxs-lookup"><span data-stu-id="84a8d-130">No-tracking queries don't use the change tracker and don't do identity resolution.</span></span> <span data-ttu-id="84a8d-131">Sie erhalten also auch dann eine neue Instanz der Entität, wenn dieselbe Entität mehrmals im Ergebnis enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="84a8d-131">So you get back a new instance of the entity even when the same entity is contained in the result multiple times.</span></span> <span data-ttu-id="84a8d-132">Dieses Verhalten war in Versionen vor EF Core 3.0 anders, siehe [frühere Versionen](#previous-versions).</span><span class="sxs-lookup"><span data-stu-id="84a8d-132">This behavior was different in versions before EF Core 3.0, see [previous versions](#previous-versions).</span></span>

<span data-ttu-id="84a8d-133">Ab EF Core 5.0 können Sie beide oben genannten Verhalten in derselben Abfrage kombinieren.</span><span class="sxs-lookup"><span data-stu-id="84a8d-133">Starting with EF Core 5.0, you can combine both of the above behaviors in same query.</span></span> <span data-ttu-id="84a8d-134">Das heißt, Sie können eine Abfrage ohne Nachverfolgung haben, die eine Identitätsauflösung in den Ergebnissen vornimmt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-134">That is, you can have a no tracking query, which will do identity resolution in the results.</span></span> <span data-ttu-id="84a8d-135">Genau wie den abfragbaren Operator `AsNoTracking()` haben wir mit `AsNoTrackingWithIdentityResolution()` einen weiteren Operator hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-135">Just like `AsNoTracking()` queryable operator, we've added another operator `AsNoTrackingWithIdentityResolution()`.</span></span> <span data-ttu-id="84a8d-136">Der Enumeration <xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> wurde außerdem ein zugeordneter Eintrag hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-136">There's also associated entry added in the <xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> enum.</span></span> <span data-ttu-id="84a8d-137">Wenn Sie die Abfrage so konfigurieren, dass die Identitätsauflösung ohne Nachverfolgung verwendet wird, verwenden wir bei der Generierung der Abfrageergebnisse eine eigenständige Änderungsnachverfolgung im Hintergrund, sodass jede Instanz sich nur einmal materialisiert.</span><span class="sxs-lookup"><span data-stu-id="84a8d-137">When you configure the query to use identity resolution with no tracking, we use a stand-alone change tracker in the background when generating query results so each instance is materialized only once.</span></span> <span data-ttu-id="84a8d-138">Da sich diese Änderungsnachverfolgung von der im Kontext unterscheidet, werden die Ergebnisse nicht vom Kontext nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-138">Since this change tracker is different from the one in the context, the results are not tracked by the context.</span></span> <span data-ttu-id="84a8d-139">Nachdem die Abfrage vollständig aufgezählt ist, verlässt die Änderungsnachverfolgung den Gültigkeitsbereich, und die Garbage Collection erfolgt den Anforderungen entsprechend.</span><span class="sxs-lookup"><span data-stu-id="84a8d-139">After the query is enumerated fully, the change tracker goes out of scope and garbage collected as required.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTrackingWithIdentityResolution)]

## <a name="tracking-and-custom-projections"></a><span data-ttu-id="84a8d-140">Nachverfolgung und benutzerdefinierte Projektionen</span><span class="sxs-lookup"><span data-stu-id="84a8d-140">Tracking and custom projections</span></span>

<span data-ttu-id="84a8d-141">Selbst wenn der Ergebnistyp der Abfrage kein Entitätstyp ist, verfolgt EF Core im Ergebnis enthaltene Entitätstypen standardmäßig nach.</span><span class="sxs-lookup"><span data-stu-id="84a8d-141">Even if the result type of the query isn't an entity type, EF Core will still track entity types contained in the result by default.</span></span> <span data-ttu-id="84a8d-142">In der folgenden Abfrage, die einen anonymen Typ zurückgibt, werden die Instanzen von `Blog` im Ergebnis nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-142">In the following query, which returns an anonymous type, the instances of `Blog` in the result set will be tracked.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection1)]

<span data-ttu-id="84a8d-143">Wenn das Resultset Entitätstypen enthält, die aus der LINQ-Komposition stammen, werden sie von EF Core nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-143">If the result set contains entity types coming out from LINQ composition, EF Core will track them.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

<span data-ttu-id="84a8d-144">Wenn das Resultset keine Entitätstypen enthält, wird keine Nachverfolgung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-144">If the result set doesn't contain any entity types, then no tracking is done.</span></span> <span data-ttu-id="84a8d-145">In der folgenden Abfrage geben wir einen anonymen Typ mit einigen Werten der Entität zurück (aber keine Instanzen des aktuellen Entitätstyps).</span><span class="sxs-lookup"><span data-stu-id="84a8d-145">In the following query, we return an anonymous type with some of the values from the entity (but no instances of the actual entity type).</span></span> <span data-ttu-id="84a8d-146">Es sind keine aus der Abfrage stammenden nachverfolgten Entitäten vorhanden.</span><span class="sxs-lookup"><span data-stu-id="84a8d-146">There are no tracked entities coming out of the query.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection3)]

 <span data-ttu-id="84a8d-147">EF Core unterstützt die Clientauswertung in der Projektion auf oberster Ebene.</span><span class="sxs-lookup"><span data-stu-id="84a8d-147">EF Core supports doing client evaluation in the top-level projection.</span></span> <span data-ttu-id="84a8d-148">Wenn EF Core eine Entitätsinstanz für die Clientauswertung materialisiert, wird sie nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-148">If EF Core materializes an entity instance for client evaluation, it will be tracked.</span></span> <span data-ttu-id="84a8d-149">Da wir hier `blog`-Entitäten an die Clientmethode `StandardizeURL` übergeben, verfolgt EF Core auch die Bloginstanzen nach.</span><span class="sxs-lookup"><span data-stu-id="84a8d-149">Here, since we're passing `blog` entities to the client method `StandardizeURL`, EF Core will track the blog instances too.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientMethod)]

<span data-ttu-id="84a8d-150">EF Core verfolgt nicht die schlüssellosen Entitätsinstanzen nach, die im Ergebnis enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="84a8d-150">EF Core doesn't track the keyless entity instances contained in the result.</span></span> <span data-ttu-id="84a8d-151">EF Core verfolgt jedoch alle anderen Instanzen von Entitätstypen mit Schlüssel gemäß den oben aufgeführten Regeln nach.</span><span class="sxs-lookup"><span data-stu-id="84a8d-151">But EF Core tracks all the other instances of entity types with a key according to rules above.</span></span>

<span data-ttu-id="84a8d-152">Einige der oben genannten Regeln funktionierten vor EF Core 3.0 anders.</span><span class="sxs-lookup"><span data-stu-id="84a8d-152">Some of the above rules worked differently before EF Core 3.0.</span></span> <span data-ttu-id="84a8d-153">Weitere Informationen siehe [frühere Versionen](#previous-versions).</span><span class="sxs-lookup"><span data-stu-id="84a8d-153">For more information, see [previous versions](#previous-versions).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="84a8d-154">Vorherige Versionen</span><span class="sxs-lookup"><span data-stu-id="84a8d-154">Previous versions</span></span>

<span data-ttu-id="84a8d-155">Vor Version 3.0 wies EF Core bei der Nachverfolgung einige Unterschiede auf.</span><span class="sxs-lookup"><span data-stu-id="84a8d-155">Before version 3.0, EF Core had some differences in how tracking was done.</span></span> <span data-ttu-id="84a8d-156">Wesentliche Unterschiede sind:</span><span class="sxs-lookup"><span data-stu-id="84a8d-156">Notable differences are as follows:</span></span>

- <span data-ttu-id="84a8d-157">Wie auf der Seite [Clientauswertung im Vergleich zur Serverauswertung](xref:core/querying/client-eval) erläutert, unterstützte EF Core vor Version 3.0 die Clientauswertung in einem beliebigen Teil der Abfrage.</span><span class="sxs-lookup"><span data-stu-id="84a8d-157">As explained in the [Client vs Server Evaluation](xref:core/querying/client-eval) page, EF Core supported client evaluation in any part of the query before version 3.0.</span></span> <span data-ttu-id="84a8d-158">Die Clientauswertung verursachte Materialisierungen von Entitäten, die nicht Teil des Ergebnisses waren.</span><span class="sxs-lookup"><span data-stu-id="84a8d-158">Client evaluation caused materialization of entities, which weren't part of the result.</span></span> <span data-ttu-id="84a8d-159">Daher analysierte EF Core das Ergebnis, um zu ermitteln, was nachverfolgt werden soll. Dieser Entwurf wies wie folgt bestimmte Unterschiede auf:</span><span class="sxs-lookup"><span data-stu-id="84a8d-159">So EF Core analyzed the result to detect what to track. This design had certain differences as follows:</span></span>
  - <span data-ttu-id="84a8d-160">Clientauswertung in der Projektion, die die Materialisierung verursachte, aber die materialisierte Entitätsinstanz nicht zurückgab, wurde nicht nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-160">Client evaluation in the projection, which caused materialization but didn't return the materialized entity instance wasn't tracked.</span></span> <span data-ttu-id="84a8d-161">Im folgenden Beispiel wurden `blog`-Entitäten nicht nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-161">The following example didn't track `blog` entities.</span></span>
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

  - <span data-ttu-id="84a8d-162">In bestimmten Fällen wurden aus der LINQ-Komposition stammende Objekte von EF Core nicht nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-162">EF Core didn't track the objects coming out of LINQ composition in certain cases.</span></span> <span data-ttu-id="84a8d-163">Im folgenden Beispiel wurde `Post` nicht nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-163">The following example didn't track `Post`.</span></span>
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

- <span data-ttu-id="84a8d-164">Wenn Abfrageergebnisse schlüssellose Entitätstypen enthielten, wurde die gesamte Abfrage nicht nachverfolgt.</span><span class="sxs-lookup"><span data-stu-id="84a8d-164">Whenever query results contained keyless entity types, the whole query was made non-tracking.</span></span> <span data-ttu-id="84a8d-165">Dies bedeutet, dass Entitätstypen mit Schlüsseln, die sich im Ergebnis befanden, auch nicht nachverfolgt wurden.</span><span class="sxs-lookup"><span data-stu-id="84a8d-165">That means that entity types with keys, which are in the result weren't being tracked either.</span></span>
- <span data-ttu-id="84a8d-166">EF Core führte in Abfragen ohne Nachverfolgung eine Identitätsauflösung durch.</span><span class="sxs-lookup"><span data-stu-id="84a8d-166">EF Core used to do identity resolution in no-tracking queries.</span></span> <span data-ttu-id="84a8d-167">Schwache Verweise wurden verwendet, um bereits zurückgegebene Entitäten nachzuverfolgen.</span><span class="sxs-lookup"><span data-stu-id="84a8d-167">It used weak references to keep track of entities that had already been returned.</span></span> <span data-ttu-id="84a8d-168">Wenn also ein Resultset dieselbe Entität mehrfach enthielt, erhielten Sie für jedes Vorkommen dieselbe Instanz.</span><span class="sxs-lookup"><span data-stu-id="84a8d-168">So if a result set contained the same entity multiples times, you would get the same instance for each occurrence.</span></span> <span data-ttu-id="84a8d-169">Auch wenn ein vorheriges Ergebnis mit derselben Identität den Gültigkeitsbereich verließ und eine Garbage Collection durchgeführt wurde, gab EF Core eine neue Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="84a8d-169">Though if a previous result with the same identity went out of scope and got garbage collected, EF Core returned a new instance.</span></span>
